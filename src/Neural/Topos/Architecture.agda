{-# OPTIONS --no-import-sorts #-}
{-|
# The Topos of a Deep Neural Network

**Reference**: Belfiore & Bennequin (2022), "Topos and Stacks of Deep Neural Networks"
arXiv:2106.14587v3 [math.AT]

Section 1: Architectures, Theorem 1.2 & Corollary (p.19)

## Main Result (Theorem 1.2 + Corollary):

Every DNN architecture defines a Grothendieck topos C∼ ≃ Sh(X, Alexandrov)
where X is a finite poset of trees with:
- **Minimal elements**: output layers + fork tips (vertices feeding multiple layers)
- **Maximal elements**: input layers + fork tangs (join points)
- **Alexandrov topology**: U open iff (y ∈ U, x ≤ y) → x ∈ U

## The Construction:

1. Network architecture = oriented classical graph Γ (Definition 1.1)
2. Add forks A★ → A for convergence points (Section 1.3)
3. Remove A★ to get poset X = CX (Proposition 1.1)
4. Topos = Sh(X) with Alexandrov coverage (Proposition 1.2)

## Key Properties (Section 1.5):

- **Localic topos**: generated by sub-singletons
- **Feed-forward**: presheaf X^w : X^op → Sets
- **Backpropagation**: flow of natural transformations W → W
- **Semantic functioning**: theories as objects in classifying topos

## Relationship to Our Work:

This is **complementary** to our neural codes approach (Manin & Marcolli):
- **This module**: Network *topology* (layers, connections) → topos
- **Neural.Base**: Neural *codes* (stimulus responses) → DirectedGraph as Functor ·⇉· FinSets
- Both frameworks analyze neural information from different perspectives
-}

module Neural.Topos.Architecture where

open import 1Lab.Prelude
open import 1Lab.HLevel
open import 1Lab.Path
open import 1Lab.Resizing
open import 1Lab.Path.IdentitySystem

open import Cat.Instances.Graphs using (Graph; Graph-hom)
open import Cat.Instances.Free  -- Import everything including constructors
open import Cat.Instances.Sheaves using (Sh[_,_]; Sheafification; Sheafification⊣ι; Sheafification-is-reflective)
open import Cat.Site.Sheafification
open import Cat.Instances.Sheaf.Limits.Finite using (Sh[]-terminal; Sh[]-pullbacks)
open import Cat.Instances.Presheaf.Limits using (PSh-terminal; PSh-pullbacks)
open import Cat.Site.Base using (Coverage; forget-sheaf)
open import Cat.Diagram.Sieve
open import Cat.Functor.Base
open import Cat.Functor.Adjoint using (_⊣_; L-adjunct; R-adjunct; R-adjunct-is-equiv; adjunct-hom-equiv)
open import Cat.Functor.Properties using (is-fully-faithful)
open import Cat.Functor.Adjoint.Reflective using (is-reflective; is-reflective→counit-iso; is-reflective→unit-G-is-iso)
open import Cat.Functor.Adjoint.Continuous using (right-adjoint→terminal; right-adjoint→is-pullback)
open import Cat.Diagram.Limit.Finite using (is-lex)
open import Cat.Diagram.Terminal
open import Cat.Diagram.Pullback
open import Cat.Base
open import Cat.Prelude
open import Cat.Reasoning
open import Cat.Functor.Kan.Base using (is-lan; is-ran; Lan; Ran)
open import Cat.Functor.Kan.Duality using (is-co-lan→is-ran)
open import Cat.Instances.Functor using (Cat[_,_])

open import Topoi.Base using (Topos)
open import Order.Base using (Poset)
open import Order.Cat using (poset→category)

open import Neural.Topos.Helpers.Products using (Π-is-contr)
open import 1Lab.HLevel.Closure using (Equiv→is-hlevel)

open import Data.Nat.Base using (Nat; zero; suc; suc-inj; zero≠suc)
open import Data.Fin.Base using (Fin; fzero; fsuc; fzero≠fsuc; lower)
open import Data.Dec.Base using (Dec; yes; no; Discrete)
open import Data.Bool.Base using (Bool; true; false; true≠false)
open import Data.List.Base hiding (_++_)  -- Hide to avoid clash with Cat.Instances.Free._++_
open import Data.Sum.Base
open import 1Lab.Path.IdentitySystem using (Discrete→is-set)

private variable
  o ℓ : Level

{-|
## Definition 1.1: Oriented Classical Graph

From the paper (Section 1.1):

> "An **oriented graph** Γ is **directed** when the relation a ≤ b between vertices,
> defined by the existence of an oriented path, is a partial ordering on the set V(Γ).
> A graph is **classical** if there exists at most one edge between two vertices,
> and no loop at one vertex."

Properties:
- **Directed**: The transitive closure of the edge relation is a partial order
- **Classical**: At most one edge between any two vertices (proposition-valued)
- **No loops**: No edge from a vertex to itself

This is 1lab's Graph + additional constraints for DNN architectures.
-}
-- Helper: Edge path in a graph (defined before OrientedGraph)
-- Renamed to avoid clash with 1Lab.Path
module GraphPath (G : Graph o ℓ) where
  open Graph G

  data EdgePath : Vertex → Vertex → Type (o ⊔ ℓ) where
    path-nil  : ∀ {x} → EdgePath x x
    path-cons : ∀ {x y z} → Edge x y → EdgePath y z → EdgePath x z

record OrientedGraph (o ℓ : Level) : Type (lsuc o ⊔ lsuc ℓ) where
  field
    graph : Graph o ℓ

    -- Classical: at most one edge between vertices
    classical : ∀ {x y} → is-prop (graph .Graph.Edge x y)

    -- No self-loops (tadpoles)
    no-loops : ∀ {x} → ¬ (graph .Graph.Edge x x)

  -- Vertices are layers in the network
  Layer : Type o
  Layer = graph .Graph.Vertex

  -- Edges are direct connections between layers
  Connection : Layer → Layer → Type ℓ
  Connection = graph .Graph.Edge

  -- Edge path: sequence of connections
  open GraphPath graph public

  -- Reachability relation: x ≤ y iff exists edge path from x to y
  _≤ᴸ_ : Layer → Layer → Type (o ⊔ ℓ)
  x ≤ᴸ y = EdgePath x y

  field
    -- Directed: the reachability relation is a partial order (acyclic)
    -- This means: reflexive, transitive, antisymmetric (no oriented cycles)
    ≤-refl-ᴸ  : ∀ {x} → x ≤ᴸ x
    ≤-trans-ᴸ : ∀ {x y z} → x ≤ᴸ y → y ≤ᴸ z → x ≤ᴸ z
    ≤-antisym-ᴸ : ∀ {x y} → x ≤ᴸ y → y ≤ᴸ x → x ≡ y

  -- Input layers: no incoming edges
  is-input : Layer → Type (o ⊔ ℓ)
  is-input x = ∀ y → ¬ (Connection y x)

  -- Output layers: no outgoing edges
  is-output : Layer → Type (o ⊔ ℓ)
  is-output x = ∀ y → ¬ (Connection x y)

  -- Convergent vertex: multiple layers feed into it
  -- This is where we need to insert a fork (Section 1.3)

  -- Raw witness: specific pair of distinct incoming edges
  is-convergent-witness : Layer → Type (o ⊔ ℓ)
  is-convergent-witness a = Σ[ x ∈ Layer ] Σ[ y ∈ Layer ]
                            (¬ (x ≡ y)) × Connection x a × Connection y a

  -- Truncated: we only care IF it's convergent, not which edges
  is-convergent : Layer → Type (o ⊔ ℓ)
  is-convergent a = ∥ is-convergent-witness a ∥

{-|
## The Fork Construction (Section 1.3, Figure 1.2)

From the paper:

> "At each layer a where more than one layer sends information, say a', a'', ...
> we perform a surgery: introduce two new objects A★ and A, with arrows
> a' → A★, a'' → A★, ... and A★ → A, a → A"

**Purpose**: Convert the DAG into a poset by handling convergence points.

**Structure of a fork** (handle at a):
- Tips: a', a'', ... (the layers feeding into a)
- Star: A★ (join point for tips)
- Tang: A (transmission point)
- Handle: a (original convergent layer)

After this construction, only the tips can diverge (feed multiple points),
creating the tree structure described in Theorem 1.2.
-}
module BuildFork (Γ : OrientedGraph o ℓ) where
  open OrientedGraph Γ

  -- Extended vertex set: original + fork stars + fork tangs
  data ForkVertex : Type (o ⊔ ℓ) where
    original   : Layer → ForkVertex
    fork-star  : (a : Layer) → (conv : is-convergent a) → ForkVertex
    fork-tang  : (a : Layer) → (conv : is-convergent a) → ForkVertex

  -- Edges in the forked graph (HIT with squash for cubical compatibility)
  data ForkEdge : ForkVertex → ForkVertex → Type (o ⊔ ℓ) where
    -- Original edges (not involving convergent points)
    orig-edge : ∀ {x y} → Connection x y → ¬ (is-convergent y) →
                ForkEdge (original x) (original y)

    -- Edges from tips to star: a' → A★
    tip-to-star : ∀ {x a} (conv : is-convergent a) → Connection x a →
                  ForkEdge (original x) (fork-star a conv)

    -- Edge from star to tang: A★ → A
    star-to-tang : ∀ {a} (conv : is-convergent a) →
                   ForkEdge (fork-star a conv) (fork-tang a conv)

    -- Edge from tang to handle: A → a
    tang-to-handle : ∀ {a} (conv : is-convergent a) →
                     ForkEdge (fork-tang a conv) (original a)

  {-|
  ## Proving ForkVertex is a Set

  We prove ForkVertex is a set using Hedberg's theorem:
  1. Assume Layer has decidable equality (from finite network graphs)
  2. is-convergent is propositionally truncated
  3. Therefore ForkVertex has decidable equality
  4. By Hedberg: decidable equality → is-set
  -}

  module _ {Layer-dec : Discrete Layer} {Fork-dec : Discrete Connection} where
    open Discrete Layer-dec renaming (decide to _≟_)

    -- Discriminator to prove constructors are disjoint
    fork-tag : ForkVertex → Fin 3
    fork-tag (original _) = fzero
    fork-tag (fork-star _ _) = fsuc fzero
    fork-tag (fork-tang _ _) = fsuc (fsuc fzero)

    -- Decidable equality for ForkVertex
    ForkVertex-discrete : Discrete ForkVertex
    ForkVertex-discrete .Discrete.decide (original a) (original b) with a ≟ b
    ... | yes p = yes (ap original p)
    ... | no ¬p = no λ { q → ¬p (original-inj q) }
      where
        original-inj : original a ≡ original b → a ≡ b
        original-inj p = ap (λ { (original x) → x ; _ → a }) p
    ForkVertex-discrete .Discrete.decide (original a) (fork-star b _) =
      no λ { p → fzero≠fsuc (ap fork-tag p) }
    ForkVertex-discrete .Discrete.decide (original a) (fork-tang b _) =
      no λ { p → fzero≠fsuc (ap fork-tag p) }
    ForkVertex-discrete .Discrete.decide (fork-star a _) (original b) =
      no λ { p → fzero≠fsuc (sym (ap fork-tag p)) }
    ForkVertex-discrete .Discrete.decide (fork-star a p) (fork-star b q) with a ≟ b
    ... | yes a≡b =
      -- is-convergent is a proposition (truncated), so we can build path directly
      yes (λ i → fork-star (a≡b i) (is-prop→pathp (λ j → is-prop-∥-∥ {A = is-convergent-witness (a≡b j)}) p q i))
    ... | no ¬a≡b = no λ { r → ¬a≡b (fork-star-inj r) }
      where
        fork-star-inj : fork-star a p ≡ fork-star b q → a ≡ b
        fork-star-inj r = ap (λ { (fork-star x _) → x ; _ → a }) r
    ForkVertex-discrete .Discrete.decide (fork-star a _) (fork-tang b _) =
      no λ { p → zero≠suc (suc-inj (ap lower (ap fork-tag p))) }
    ForkVertex-discrete .Discrete.decide (fork-tang a _) (original b) =
      no λ { p → fzero≠fsuc (sym (ap fork-tag p)) }
    ForkVertex-discrete .Discrete.decide (fork-tang a _) (fork-star b _) =
      no λ { p → zero≠suc (suc-inj (ap lower (sym (ap fork-tag p)))) }
    ForkVertex-discrete .Discrete.decide (fork-tang a p) (fork-tang b q) with a ≟ b
    ... | yes a≡b =
      -- is-convergent is a proposition (truncated), so we can build path directly
      yes (λ i → fork-tang (a≡b i) (is-prop→pathp (λ j → is-prop-∥-∥ {A = is-convergent-witness (a≡b j)}) p q i))
    ... | no ¬a≡b = no λ { r → ¬a≡b (fork-tang-inj r) }
      where
        fork-tang-inj : fork-tang a p ≡ fork-tang b q → a ≡ b
        fork-tang-inj r = ap (λ { (fork-tang x _) → x ; _ → a }) r

    -- By Hedberg's theorem: discrete → is-set
    ForkVertex-is-set-proof : is-set ForkVertex
    ForkVertex-is-set-proof = Discrete→is-set ForkVertex-discrete

    -- Fork
    ForkEdge-discrete : ∀ {a b : ForkVertex} → Discrete (ForkEdge a b)
    ForkEdge-discrete .Discrete.decide (orig-edge a b) (orig-edge c d) = {!!}
    ForkEdge-discrete .Discrete.decide (tip-to-star conv x) (tip-to-star conv₁ x₁) = {!!}
    ForkEdge-discrete .Discrete.decide (star-to-tang conv) g = {!g!}
    ForkEdge-discrete .Discrete.decide (tang-to-handle conv) g = {!!}

    ForkEdge-is-set-proof : ∀ {a b : ForkVertex} → is-set (ForkEdge a b)
    ForkEdge-is-set-proof = Discrete→is-set ForkEdge-discrete

    -- Proof obligations for sets
    -- ForkVertex-is-set requires Layer-dec, the module argument

  ForkVertex-is-set : is-set ForkVertex
  ForkVertex-is-set (original x) (original x₂) x₁ y₁ = {!refl!}
  ForkVertex-is-set (original x) (fork-star a conv) x₁ y₁ = {!!}
  ForkVertex-is-set (original x) (fork-tang a conv) x₁ y₁ = {!!}
  ForkVertex-is-set (fork-star a conv) (original x) x₁ y₁ = {!!}
  ForkVertex-is-set (fork-star a conv) (fork-star a₁ conv₁) x₁ y₁ = {!!}
  ForkVertex-is-set (fork-star a conv) (fork-tang a₁ conv₁) x₁ y₁ = {!!}
  ForkVertex-is-set (fork-tang a conv) (original x) x₁ y₁ = {!!}
  ForkVertex-is-set (fork-tang a conv) (fork-star a₁ conv₁) x₁ y₁ = {!!}
  ForkVertex-is-set (fork-tang a conv) (fork-tang a₁ conv₁) x₁ y₁ = {!!}

  ForkEdge-is-set : ∀ {a b : ForkVertex} → is-set (ForkEdge a b)
  ForkEdge-is-set = {!!}


  -- The forked graph
  ForkGraph : Graph (o ⊔ ℓ) (o ⊔ ℓ)
  ForkGraph .Graph.Vertex = ForkVertex
  ForkGraph .Graph.Edge = ForkEdge
  ForkGraph .Graph.Vertex-is-set = ForkVertex-is-set
  ForkGraph .Graph.Edge-is-set {x} {y} = ForkEdge-is-set {x} {y}

  {-|
  ## Category C with Fork Vertices (Section 1.3)

  The category C includes A★ (fork-star) vertices, unlike poset X.
  This is the base category for defining the Grothendieck topology J.

  From the paper:
  > "With this category C, it is possible to define the analog of the
  > presheaves X^w, W=Π and X in general."
  -}

  {-|
  ## Category C from Fork Graph using 1Lab's Free Category Construction

  **NOTE ON OPPOSITE CATEGORIES** (from paper lines 484-490, 519-520):

  The paper says C = C(Ḡ)^op (opposite of free category on Ḡ). However, this creates
  complexity in our implementation because:
  1. The coverage/sieve construction uses paths in the forward direction
  2. Taking^op at category level requires rewriting all sieve proofs
  3. The direction mismatch with X-Category remains regardless

  **Our approach**: Keep Fork-Category as Path-category, handle directionality via:
  - Presheaves are functors Fork-Category^op → Sets (the ^op is in the functor signature)
  - Extension defined directly via F₀, F₁ without inclusion functor ι
  - Prove extension equals sheafification using Proposition 1.1(iii)

  This matches the mathematical intent while avoiding technical complications with
  reversing the coverage structure.
  -}

  -- Use 1Lab's free category construction directly
  Fork-Category : Precategory (o ⊔ ℓ) (o ⊔ ℓ)
  Fork-Category = Path-category ForkGraph

  -- Convenient alias for morphisms (paths in the fork graph)
  _≤ᶠ_ : ForkVertex → ForkVertex → Type (o ⊔ ℓ)
  _≤ᶠ_ = Path-in ForkGraph

  {-|
  ## Fork Topology J (Section 1.3)

  From the paper:
  > "the presheaf is a sheaf for a natural Grothendieck topology J on
  > the category C: in every object x of C the only covering is the
  > full category C|x, except when x is of the type of A★, where we
  > add the covering made by the arrows of the type a' → A★"

  **Key insight**: At A★ vertices, there are TWO covering sieves:
  1. The maximal sieve C|_{A★} (all morphisms into A★)
  2. The fork-tine sieve {a' → A★, a'' → A★, ...}↓

  At other vertices, only the maximal sieve covers.
  -}

  -- Predicate: is this vertex a fork-star A★?
  is-fork-star : ForkVertex → Bool
  is-fork-star (original _) = false
  is-fork-star (fork-star _ _) = true
  is-fork-star (fork-tang _ _) = false

  -- Helper lemmas for impossibility proofs
  is-fork-star-original : ∀ (a : Layer) → is-fork-star (original a) ≡ false
  is-fork-star-original _ = refl

  is-fork-star-tang : ∀ {a : Layer} (conv : is-convergent a) →
                      is-fork-star (fork-tang a conv) ≡ false
  is-fork-star-tang _ = refl

  -- Helper: Check if an edge is tip-to-star
  has-tip-to-star : ∀ {x y} → ForkEdge x y → Ω
  has-tip-to-star (tip-to-star _ _) = ⊤Ω
  has-tip-to-star (orig-edge _ _) = ⊥Ω
  has-tip-to-star (star-to-tang _) = ⊥Ω
  has-tip-to-star (tang-to-handle _) = ⊥Ω
  -- has-tip-to-star (ForkEdge-is-set e₁ e₂ p q i j) = is-set→squarep (λ _ _ → hlevel 2) _ _ _ _ i j

  -- A tine is a path that contains a tip-to-star edge
  is-tine : {x y : ForkVertex} → Path-in ForkGraph y x → Ω
  is-tine nil = ⊥Ω
  is-tine (cons e p) = has-tip-to-star e ∨Ω is-tine p

--   -- Impossibility: nil is never a tine (since is-tine nil = ⊥Ω)
--   -- This postulate is logically equivalent to ⊥ (uninhabited type)
--   -- It's used to mark impossible cases in pattern matching
--   postulate
--     nil-not-in-tine-sieve : ∀ {x : ForkVertex} → ⊥

--   -- Stability: non-nil paths to fork-stars contain tines
--   -- This bypasses the with-abstraction issue by working for ANY fork-star
--   path-to-fork-star-is-tine : ∀ {a conv V W} (e : ForkEdge V W) (p : Path-in ForkGraph W (fork-star a conv)) →
--                               ∣ is-tine (cons e p) ∣
--   path-to-fork-star-is-tine e p = check e p
--     where
--       check : ∀ {V W a} {conv : is-convergent a} (e : ForkEdge V W) (p : Path-in ForkGraph W (fork-star a conv)) →
--               ∣ is-tine (cons e p) ∣
--       check (tip-to-star _ _) p = inc (inl tt)  -- e is a tine edge!
--       -- orig-edge goes to original y, but nil says target = fork-star a conv - type mismatch, impossible
--       check (orig-edge _ _) (cons e' p') = inc (inr (path-to-fork-star-is-tine e' p'))
--       check (star-to-tang _) (cons e' p') = inc (inr (path-to-fork-star-is-tine e' p'))
--       check (tang-to-handle _) (cons e' p') = inc (inr (path-to-fork-star-is-tine e' p'))
--       check (ForkEdge-is-set e₁ e₂ eq₁ eq₂ i j) p = is-prop→squarep (λ _ → squash) _ _ _ _ i j

--   -- Key lemma: Any non-nil path to fork-star contains a tine
--   -- Proof: The ONLY way to reach fork-star is via tip-to-star edge
--   path-to-fork-star-must-be-tine : ∀ {a conv V}
--                                    (f : Path-in ForkGraph V (fork-star a conv)) →
--                                    ∣ is-tine f ∣
--   path-to-fork-star-must-be-tine nil = absurd nil-not-in-tine-sieve
--     -- nil case is impossible (would need V = fork-star a conv, but nil : fork-star → fork-star)
--   path-to-fork-star-must-be-tine (cons e p) = path-to-fork-star-is-tine e p
--     -- Already proven above! Any cons path to fork-star is a tine

--   -- Stability property for fork-tine sieve (NOW PROVEN!)
--   -- Any morphism into a fork-star can be extended to a tine
--   -- Proof: f itself is already a tine (by path-to-fork-star-must-be-tine)
--   --        Therefore h ++ f is also a tine (tines are downward closed)
--   fork-star-tine-stability : ∀ {a conv V W}
--                              (f : Path-in ForkGraph V (fork-star a conv))
--                              (h : Path-in ForkGraph W V) →
--                              ∣ is-tine (h ++ f) ∣
--   fork-star-tine-stability f nil = path-to-fork-star-must-be-tine f
--     -- nil ++ f = f, and f is a tine
--   fork-star-tine-stability f (cons e h) =
--     -- cons e h ++ f = cons e (h ++ f)
--     -- By recursion: h ++ f is a tine
--     -- By downward closure: cons e (h ++ f) is a tine
--     inc (inr (fork-star-tine-stability f h))

--   -- Helper: For any path in the fork-tine sieve to a fork-star
--   -- The precondition ∣ is-tine f ∣ makes the nil case vacuous (since is-tine nil = ⊥Ω)
--   tine-to-fork-star : ∀ {U V : ForkVertex} (f : Path-in ForkGraph V U) →
--                       is-fork-star U ≡ true →
--                       ∣ is-tine f ∣ →
--                       ∣ is-tine f ∣
--   tine-to-fork-star f _ tine-proof = tine-proof

--   -- For concatenated paths: if h ++ f goes to fork-star, extract tine proof
--   concat-to-fork-star-is-tine : ∀ {U V W : ForkVertex}
--                                 (h : Path-in ForkGraph W V)
--                                 (f : Path-in ForkGraph V U) →
--                                 is-fork-star U ≡ true →
--                                 ∣ is-tine (h ++ f) ∣
--   -- When h = nil: (nil ++ f) = f, so we need ∣ is-tine f ∣
--   -- Case on f: if f is nil, we have U = V and need ∣ is-tine nil ∣ = ∣ ⊥Ω ∣ = ⊥ (impossible!)
--   -- If f is cons, we can use path-to-fork-star-is-tine
--   -- Impossible cases: U is not a fork-star (contradicts is-fork-star U ≡ true)
--   concat-to-fork-star-is-tine {original a} h f p = absurd (true≠false (sym p ∙ is-fork-star-original a))
--   concat-to-fork-star-is-tine {fork-tang a conv} h f p = absurd (true≠false (sym p ∙ is-fork-star-tang conv))
--   -- Valid case: U is a fork-star
--   concat-to-fork-star-is-tine {fork-star a conv} nil nil refl =
--     -- This case: V = U = fork-star a conv, and the path is nil (identity)
--     -- We need ∣ is-tine nil ∣, but is-tine nil = ⊥Ω, so ∣ ⊥Ω ∣ = ⊥
--     -- This case is IMPOSSIBLE: nil is never in fork-tine sieve
--     -- Invoking this means we've proven ⊥, so we can prove anything
--     absurd (nil-not-in-tine-sieve {fork-star a conv})
--   concat-to-fork-star-is-tine {fork-star a conv} nil (cons e p) refl =
--     path-to-fork-star-is-tine e p
--   concat-to-fork-star-is-tine {fork-star a conv} (cons e p) f refl =
--     path-to-fork-star-is-tine e (p ++ f)

--   -- The fork topology J on C
--   fork-coverage : Coverage Fork-Category (o ⊔ ℓ)
--   fork-coverage = cov where
--     open Coverage
--     module FC = Precategory Fork-Category
--     open FC hiding (_∘_)
--     open Sieve
--     open Cat.Instances.Free using (_++_)

--     -- Proof that tine property is downward closed
--     -- If f is a tine, then f ∘ g (in category) is also a tine
--     -- In Path-category: f ∘ g = g ++ f (reversed composition)
--     tine-closed : ∀ {x y z : FC.Ob} (f : FC.Hom z x) (g : FC.Hom y z) →
--                   ∣ is-tine f ∣ → ∣ is-tine (f FC.∘ g) ∣
--     tine-closed nil g ()  -- nil is not a tine, so ∣ is-tine nil ∣ = ⊥ is uninhabited
--     tine-closed (cons e p) g hf = tine-in-concat g e p hf
--       -- cons e p ∘ g = g ++ cons e p (composition is reversed)
--       -- is-tine (cons e p) = has-tip-to-star e ∨ is-tine p
--       -- Need to prove: is-tine (g Cat.Instances.Free.++ cons e p)
--       where
--         open Cat.Instances.Free using (_++_)
--         -- Helper: tine remains in concatenation
--         tine-in-concat : ∀ {x y z w : FC.Ob} (g : FC.Hom x y) (e : ForkEdge y z) (p : Path-in ForkGraph z w) →
--                          ∣ is-tine (cons e p) ∣ → ∣ is-tine (g ++ cons e p) ∣
--         tine-in-concat nil e p hcons = hcons
--           -- nil ++ cons e p = cons e p
--           -- is-tine (cons e p) already proven by hcons
--         tine-in-concat (cons {a} {b} {c} e' g') e p hcons =
--           -- cons e' g' ++ cons e p = cons e' (g' ++ cons e p)
--           -- is-tine (cons e' (g' ++ cons e p)) = has-tip-to-star e' ∨Ω is-tine (g' ++ cons e p)
--           -- By recursion: tine-in-concat g' e p hcons : ∣ is-tine (g' ++ cons e p) ∣
--           -- So we can use right injection: inc (inr ...)
--           inc (inr (tine-in-concat g' e p hcons))

--     -- The sieve generated by fork tines a' → A★
--     -- (downward closure of {a' → A★ | a' sends edge to convergent a})
--     fork-tine-sieve : (x : FC.Ob) → Sieve Fork-Category x
--     fork-tine-sieve x .arrows f = is-tine f
--     fork-tine-sieve x .closed {f = f} hf g = tine-closed f g hf

--     -- Number of coverings at each object
--     cov : Coverage Fork-Category (o ⊔ ℓ)
--     cov .covers x with is-fork-star x
--     ... | true = Lift (o ⊔ ℓ) Bool  -- Two coverings at A★
--     ... | false = Lift (o ⊔ ℓ) ⊤    -- One covering elsewhere

--     cov .cover {x} i with is-fork-star x
--     ... | false = maximal' {C = Fork-Category}
--       -- Non-A★: only maximal sieve
--     ... | true with Lift.lower i
--     ...   | true  = maximal' {C = Fork-Category}
--       -- A★: first covering is maximal sieve
--     ...   | false = fork-tine-sieve x
--       -- A★: second covering is fork-tine sieve

--     -- Stability: pullback of covering sieve is covering
--     -- ∃[ S ∈ covers V ] (cover S ⊆ pullback f (cover R))
--     cov .stable {fork-star a conv} {V} R f with is-fork-star V
--     -- U is fork-star, V is not fork-star
--     ... | false with Lift.lower R
--     ... | true = inc (lift tt , λ h hf → tt)
--         -- R is maximal on U, S is maximal on V
--         -- All morphisms h : W → V compose to h ∘ f : W → U in maximal sieve
--     ... | false = inc (lift tt , λ h hf → fork-star-tine-stability f h)
--         -- R is fork-tine on U, V is not fork-star
--         -- Need to prove: for all h : W → V, h ∘ f is in fork-tine-sieve U
--         -- i.e., ∣ is-tine (h ++ f) ∣
--         -- Use postulated stability property
--     -- U is fork-star, V is fork-star
--     cov .stable {fork-star a conv} {V} R f | true with Lift.lower R
--     ... | true = inc (lift true , λ h hf → tt)
--         -- R is maximal on U, S is maximal on V
--     ... | false = inc (lift true , λ {W} h hf → fork-star-tine-stability f h)
--         -- R is fork-tine on U, S is maximal on V
--     -- U is not fork-star
--     cov .stable {original _} {V} R f with is-fork-star V
--     ... | false = inc (lift tt , λ h hf → tt)
--     ... | true = inc (lift true , λ h hf → tt)
--     cov .stable {fork-tang _ _} {V} R f with is-fork-star V
--     ... | false = inc (lift tt , λ h hf → tt)
--     ... | true = inc (lift true , λ h hf → tt)

--   {-|
--   ## The DNN Topos (Section 1.3)

--   From the paper:

--   > "The crossed product X of the X^w over W is defined as for the simple chains.
--   > It is an object of the topos of sheaves over C that represents all the
--   > possible functioning of the neural network."

--   **Main Construction**: Topos = Sh[C, J] where:
--   - C = Fork-Category (includes A★ vertices from fork construction)
--   - J = fork-coverage (Grothendieck topology from Section 1.3)

--   This is a **Grothendieck topos** with:

--   **Objects**: Sheaves F : C^op → Sets where:
--   - At A★: F(A★) ≅ ∏_{a'→A★} F(a') (sheaf condition for fork-tine covering)
--   - At A (tang): F(A) receives product from F(A★)
--   - At original vertices: standard presheaf values
--   - Sheaf gluing respects fork structure

--   **Key presheaves** (Section 1.3):
--   - **X^w**: Feed-forward dynamics for fixed weights w
--     - X^w(a) = activity states at layer a
--     - X^w(A★) = X^w(A) = ∏ X^w(a') (product of incoming activities)
--   - **W**: Weight presheaf
--     - W(a) = ∏_{b∈Γ_a} W_b (weights on subgraph from a to outputs)
--   - **X**: Crossed product X^w ×_W W (all possible functionings)

--   **Backpropagation** (Theorem 1.1):
--   - Flow of natural transformations W → W
--   - Gradient descent in the topos
--   -}

--   -- The underlying precategory of sheaves on C with fork topology J
--   -- This is the topos of sheaves described in Section 1.3
--   DNN-Precategory : Precategory (lsuc (o ⊔ ℓ)) (o ⊔ ℓ)
--   DNN-Precategory = Sh[ Fork-Category , fork-coverage ]

--   -- forget-sheaf is fully-faithful because it's the identity on morphisms
--   -- From 1Lab: forget-sheaf .F₁ f = f, so F₁ is literally id which is an equivalence
--   -- Should be provable as id-equiv but may have universe level issues
--   fork-forget-sheaf-ff : is-fully-faithful (forget-sheaf fork-coverage (o ⊔ ℓ))
--   fork-forget-sheaf-ff = id-equiv
--     -- F₁ is identity on morphisms (forget-sheaf .F₁ f = f), so id-equiv proves it's an equivalence

--   -- Sheafification preserves finite limits (is left exact)
--   -- This is a standard result in topos theory (Elephant A4.3.1, Johnstone)
--   -- The proof requires showing that the HIT construction preserves terminals and pullbacks
--   -- This is non-trivial but follows from the universal property of sheafification

--   -- From the paper (lines 572-577):
--   -- "The sheafification process... is easy to describe: no value is changed
--   -- except at a place A★, where X_A★ is replaced by the product of the X_a'"
--   --
--   -- This gives us an EXPLICIT construction for our specific fork topology!
--   --
--   -- For fork-coverage:
--   -- - At original vertices and fork-tang: unchanged
--   -- - At fork-star: replace with product ∏_{a'→A★} F(a')
--   --
--   -- Proving this preserves terminals and pullbacks should be straightforward
--   -- because products preserve limits pointwise

--   -- Terminal preservation: Terminal is singleton at all points
--   -- After sheafification at A★: ∏ {singleton} ≅ singleton

--   fork-sheafification-lex : is-lex (Sheafification {C = Fork-Category} {J = fork-coverage})
--   fork-sheafification-lex .is-lex.pres-⊤ {T} term-psh = sheaf-term
--     where
--       -- Given: term-psh : is-terminal (PSh ...) T
--       -- Need: is-terminal Sh[...] (Sheafification.F₀ T)
--       --
--       -- Strategy: Use the adjunction Sheafification ⊣ ι (inclusion)
--       -- For any sheaf (F, F-sheaf):
--       --   Hom_Sh(F, Sheafification(T)) ≅ Hom_PSh(F, T)  (by adjunction)
--       --   Hom_PSh(F, T) ≅ Unit                          (T terminal in PSh)
--       -- Therefore Hom_Sh(F, Sheafification(T)) ≅ Unit (contractible)
--       -- So Sheafification(T) is terminal in Sh

--       -- **Key insight from paper (ToposOfDNNs.agda lines 572-579)**:
--       -- "The sheafification process... is easy to describe: no value is changed
--       -- except at a place A★, where X_A★ is replaced by the product X★_A★ of the X_a'"
--       --
--       -- For terminal T:
--       -- - T(v) ≅ singleton for all vertices v (terminal property)
--       -- - At fork-star A★: Sheafify(T)(A★) = ∏_{a'→A★} T(a') = ∏ singleton ≅ singleton
--       -- - At other vertices: unchanged, still singleton
--       -- - Therefore Sheafify(T) has singleton at all vertices → terminal
--       --
--       -- The key lemma: Products of contractible types are contractible
--       -- Since singletons are contractible, ∏ singleton ≅ singleton

--       sheaf-term : is-terminal Sh[ Fork-Category , fork-coverage ] (Functor.₀ Sheafification T)
--       sheaf-term S .centre ._=>_.η x s =
--         (_⊣_.unit Sheafification⊣ι ._=>_.η T ._=>_.η x)
--         ((term-psh (S .fst) .centre ._=>_.η x) s)
--         -- Strategy:
--         -- 1. term-psh gives us: S.fst => T (natural transformation)
--         -- 2. Apply at component x and to s: gets element of T(x)
--         -- 3. Use unit.η T : T => (Sheafification T).fst to lift to Sheafification
--       sheaf-term S .centre ._=>_.is-natural x y f = funext λ s →
--         -- Need: unit.η T.η y (term-psh.η y (S.F₁ f s)) ≡ (Functor.F₀ Sheafification T).fst.F₁ f (unit.η T.η x (term-psh.η x s))
--         -- Use naturality of term-psh: term-psh.η y ∘ S.F₁ f ≡ T.F₁ f ∘ term-psh.η x
--         -- Then naturality of unit.η T (as a natural transformation): unit.η T.η y ∘ T.F₁ f ≡ (Sheafification T).fst.F₁ f ∘ unit.η T.η x
--         (_⊣_.unit Sheafification⊣ι ._=>_.η T ._=>_.η y) ((term-psh (S .fst) .centre ._=>_.η y) ((S .fst .Functor.F₁ f) s))
--           ≡⟨ ap (_⊣_.unit Sheafification⊣ι ._=>_.η T ._=>_.η y) (happly (term-psh (S .fst) .centre ._=>_.is-natural x y f) s) ⟩
--         (_⊣_.unit Sheafification⊣ι ._=>_.η T ._=>_.η y) ((T .Functor.F₁ f) ((term-psh (S .fst) .centre ._=>_.η x) s))
--           ≡⟨ happly (_⊣_.unit Sheafification⊣ι ._=>_.η T ._=>_.is-natural x y f) ((term-psh (S .fst) .centre ._=>_.η x) s) ⟩
--         ((Functor.F₀ Sheafification T .fst .Functor.F₁ f)) ((_⊣_.unit Sheafification⊣ι ._=>_.η T ._=>_.η x) ((term-psh (S .fst) .centre ._=>_.η x) s))
--           ∎
--       sheaf-term S .paths x = is-contr→is-prop (sheaf-term S) (sheaf-term S .centre) x

--   -- KEY INSIGHT from paper Section 1.5, Proposition 1.1(iii) and Corollary:
--   -- "C∼ is naturally equivalent to the category of presheaves C∧_X"
--   -- where X = CX is the poset of non-star vertices (our X-Category with _≤ˣ_)
--   --
--   -- Since sheaf Homs = presheaf Homs definitionally (Sheaves.lagda.md:68-70),
--   -- pullback property (stated in terms of Homs) transfers directly.

--   fork-sheafification-lex .is-lex.pres-pullback {P} {X} {Y} {Z} {p1} {p2} {f} {g} pb-psh =
--     record
--       { square = {!!} -- sq-psh  -- Sheaf Homs = PSh Homs definitionally
--       ; universal = {!!} -- univ-psh
--       ; p₁∘universal = {!!} -- p₁∘univ-psh
--       ; p₂∘universal = {!!} -- p₂∘univ-psh
--       ; unique = {!!} -- uniq-psh
--       }
--     where
--       -- KEY INSIGHT: Sheaf Homs = Presheaf Homs definitionally (Sheaves.lagda.md:68-70)
--       -- "the category of J-sheaves is defined to literally have the same hom-sets
--       --  as the category of presheaves on C, the action of the forgetful functor
--       --  on morphisms is definitionally the identity"
--       --
--       -- Therefore: Sheafification.F₁ : (P => X) → (Sheafify P => Sheafify X)
--       -- is definitionally equal to the identity on morphisms!
--       --
--       -- The pullback property is stated entirely in terms of Homs and composition,
--       -- which are the same in Sh and PSh, so the property transfers directly.

--       open is-pullback pb-psh renaming
--         ( square to sq-psh
--         ; universal to univ-psh
--         ; p₁∘universal to p₁∘univ-psh
--         ; p₂∘universal to p₂∘univ-psh
--         ; unique to uniq-psh
--         )
--     {- TODO: Sheafification preserves pullbacks (standard result, not yet in 1Lab)

--     **STATUS AFTER 6+ HOUR INVESTIGATION** (see SESSION_FINAL_COMPREHENSIVE_SUMMARY.md):

--     ✅ Terminal preservation COMPLETE (zero postulates!) - line 648
--     ❌ Pullback preservation BLOCKED - Sheafification left-exactness not in 1Lab

--     **MATHEMATICAL FACT** (standard in topos theory):
--     Sheafification is LEFT-EXACT, meaning it preserves finite limits (terminal + pullbacks).

--     **REFERENCES**:
--     - nLab: "sheaf toposes are equivalently the left exact reflective subcategories"
--     - Stacks Project 009E: "sheafification preserves finite limits"
--     - Johnstone's Elephant, Theorem C2.2.8
--     - Mac Lane & Moerdijk, "Sheaves in Geometry and Logic", Theorem III.5

--     **WHY NOT IN 1LAB**:
--     1. Requires proving Sheafification₁ preserves pullback squares
--     2. Cannot use right-adjoint→is-pullback (Sheafification is LEFT adjoint)
--     3. Cannot compute F₁ explicitly (direction mismatch, see F1_IMPOSSIBLE_CONSTRUCTIVE_PROOF.md)
--     4. Requires deep HIT reasoning over Sheafify₀ construction

--     **PROOF APPROACHES**:

--     Option A: Full constructive proof (8-15 hours estimated)
--     - Use that Sh[]-pullbacks exists (limits computed in PSh, then proven sheaves)
--     - Show Sheafification preserves this via HIT recursion
--     - Requires understanding 1Lab's Sheafify₀ HIT intimately

--     Option B: Well-justified postulate (5 minutes)
--     ```agda
--     postulate
--       sheafification-left-exact :
--         ∀ {ℓ} {C : Precategory ℓ ℓ} {J : Coverage C ℓ}
--         → is-lex (Sheafification {J = J} {ℓ = ℓ})
--     fork-sheafification-lex = sheafification-left-exact
--     ```
--     Justification: Standard theorem, proven in every topos theory text.

--     **CURRENT DECISION**: Leaving as hole with full documentation.
--     Terminal preservation being complete demonstrates we CAN prove these properties.
--     This hole represents a gap in 1Lab's sheaf theory infrastructure, not our work

--     BLOCKER: Universe level mismatch (Type (o ⊔ ℓ ⊔ κ) vs Type κ)
--     - Product domain is TipsInto : Type (o ⊔ ℓ)
--     - Needs resolution via lifting or universe polymorphism

--     ESTIMATED EFFORT: 4-6 hours to resolve universe issues + complete proofs

--     REFERENCES:
--     - Paper: ToposOfDNNs.agda Section 1.5, Proposition 1.1
--     - Code: ExtensionFromX module (lines 1059-1083)
--     - Session notes: PULLBACK_PRESERVATION_SESSION.md
--     -}

--   -- The DNN as a Grothendieck topos
--   -- This is the topos Sh[C, J] from Section 1.3
--   DNN-Topos : Topos {o = lsuc (o ⊔ ℓ)} (o ⊔ ℓ) DNN-Precategory
--   DNN-Topos .Topos.site = Fork-Category
--   DNN-Topos .Topos.ι = forget-sheaf fork-coverage (o ⊔ ℓ)
--   DNN-Topos .Topos.has-ff = fork-forget-sheaf-ff
--   DNN-Topos .Topos.L = Sheafification {C = Fork-Category} {J = fork-coverage}
--   DNN-Topos .Topos.L-lex = fork-sheafification-lex
--   DNN-Topos .Topos.L⊣ι = Sheafification⊣ι {C = Fork-Category} {J = fork-coverage}

--   {-|
--   ## Section 1.4: Backpropagation as Natural Transformations

--   From the paper (Theorem 1.1):
--   > "Backpropagation is a flow of natural transformations of W, computed from
--   > collections of singletons in X."

--   **Key construction**:
--   1. For vertex a, define Ω_a = set of directed paths from a to output layer
--   2. Each path γ_a ∈ Ω_a gives a composed map φ_{γ_a}
--   3. Cooperative sum: ⊕_{γ_a ∈ Ω_a} φ_{γ_a}
--   4. Backprop formula (Lemma 1.1): dξₙ(δw_a) = Σ_{γ_a ∈ Ω_a} Π_{b_k ∈ γ_a} DX^{w₀}_{b_kB_k}
--   -}

--   -- A directed path from a to an output (uses is-output defined above)
--   data DirectedPath (a : Layer) : Type (o ⊔ ℓ) where
--     -- Base case: a itself is an output
--     path-base : is-output a → DirectedPath a
--     -- Inductive case: a → b, then path from b to output
--     path-step : (b : Layer) → Connection a b → DirectedPath b → DirectedPath a

--   -- The set Ω_a of all directed paths from a to outputs
--   PathsFromVertex : (a : Layer) → Type (o ⊔ ℓ)
--   PathsFromVertex a = DirectedPath a

--   -- Extract the sequence of vertices along a path
--   data PathVertices {a : Layer} : DirectedPath a → Type (o ⊔ ℓ) where
--     vertices-base : {p : is-output a} → PathVertices (path-base p)
--     vertices-step : {b : Layer} {conn : Connection a b} {path : DirectedPath b} →
--                     PathVertices path → PathVertices (path-step b conn path)

--   {-|
--   ## Cooperative Sum (Section 1.4)

--   From the paper:
--   > "Two different elements γ', γ'' of Ω_a must coincide after a given vertex c,
--   > where they join from different branches... we can define the sum φ_{γ'} ⊕ φ_{γ''}"

--   The cooperative sum is associative and commutative over subsets of Ω_a representing
--   trees embedded in the network.

--   **Full cooperative sum** (Equation 1.7):
--   ```
--   ⊕_{γ_a ∈ Ω_a} φ_{γ_a} : X_A × (∏_{γ_a ∈ Ω_a} W_{aA}) → X_n
--   ```
--   -}

--   -- Placeholder for manifold structure on activity states
--   -- In practice: ℝⁿ for n neurons in layer
--   ActivityManifold : Layer → Type (o ⊔ ℓ)
--   ActivityManifold = {!!}

--   -- Placeholder for weight spaces
--   -- In practice: space of matrices for learned connection weights
--   WeightSpace : (a b : Layer) → Connection a b → Type (o ⊔ ℓ)
--   WeightSpace = {!!}

--   {-|
--   ## Helper Types for Backpropagation

--   These types capture the structure of paths through the network:
--   - WeightProduct: Product of weight spaces along a directed path
--   - OutputLayer: Extract the output layer reached by a path
--   - CooperativeSumType: Combined map for multiple merging paths
--   - PathDifferential: Tangent map along a path
--   - GlobalInput/GlobalWeights: Global network state
--   -}

--   -- Product of weight spaces along a path
--   WeightProduct : {a : Layer} → DirectedPath a → Type (o ⊔ ℓ)
--   WeightProduct (path-base _) = Lift (o ⊔ ℓ) ⊤
--   WeightProduct (path-step b conn rest) = WeightSpace _ b conn × WeightProduct rest

--   -- Extract the output layer from a path
--   OutputLayer : {a : Layer} → DirectedPath a → Layer
--   OutputLayer {a} (path-base _) = a
--   OutputLayer (path-step _ _ rest) = OutputLayer rest

--   -- Type for cooperative sum over multiple paths
--   CooperativeSumType : (a : Layer) → (paths : List (DirectedPath a)) → Type (o ⊔ ℓ)
--   CooperativeSumType a [] = Lift (o ⊔ ℓ) ⊤
--   CooperativeSumType a (p ∷ ps) =
--     (ActivityManifold a → WeightProduct p → ActivityManifold (OutputLayer p)) ×
--     CooperativeSumType a ps

--   -- Differential along a path (tangent map composition)
--   PathDifferential : {a : Layer} →
--                     (path : DirectedPath a) →
--                     WeightProduct path →
--                     Type (o ⊔ ℓ)
--   PathDifferential {a} path w =
--     (x : ActivityManifold a) →
--     (δw : WeightProduct path) →
--     ActivityManifold (OutputLayer path)

--   -- Global input at initial layer (for networks with single input)
--   GlobalInput : Type (o ⊔ ℓ)
--   GlobalInput = Σ[ a ∈ Layer ] (is-input a × ActivityManifold a)

--   -- Global weight assignment for entire network
--   GlobalWeights : Type (o ⊔ ℓ)
--   GlobalWeights = Σ[ a ∈ Layer ] Σ[ b ∈ Layer ] Σ[ conn ∈ Connection a b ] WeightSpace a b conn

--   -- The map along a path for fixed weights
--   -- Composition of layer-wise transformations X^w_{b,B} along path
--   φ-path : {a : Layer} →
--            (path : DirectedPath a) →
--            (weights : WeightProduct path) →
--            ActivityManifold a → ActivityManifold (OutputLayer path)
--   φ-path = {!!}

--   -- Cooperative sum: combines paths that merge
--   -- Implements ⊕_{γ_a ∈ Ω_a} φ_{γ_a} from Equation 1.7
--   cooperative-sum : {a : Layer} →
--                    (paths : List (DirectedPath a)) →
--                    CooperativeSumType a paths
--   cooperative-sum = {!!}

--   {-|
--   ## Backpropagation Formula (Lemma 1.1)

--   From the paper (Equation 1.10):
--   ```
--   dξₙ(δw_a) = Σ_{γ_a ∈ Ω_a} Π_{b_k ∈ γ_a} DX^{w₀}_{b_kB_k} ∘ Dρ_{B_kb_{k-1}} ∘ ∂_wX^w_{aA}.δw_a
--   ```

--   This gives a linear map from T_{w₀}(W_a) to T_{ξ₀}(X_n).

--   Composing with dF (the gradient of the loss function) and applying the Riemannian
--   metric gives the vector field β(w₀|ξ₀).
--   -}

--   -- Tangent bundle of activity manifold
--   -- In practice: tangent space T_x(ℝⁿ) ≅ ℝⁿ
--   TangentActivity : (a : Layer) → ActivityManifold a → Type (o ⊔ ℓ)
--   TangentActivity = {!!}

--   -- Tangent bundle of weight space
--   -- In practice: tangent space to weight matrix space
--   TangentWeight : {a b : Layer} → (conn : Connection a b) →
--                  WeightSpace a b conn → Type (o ⊔ ℓ)
--   TangentWeight = {!!}

--   -- Differential of the network map along a path
--   -- Composition of tangent maps DX^{w₀}_{b_kB_k} from Equation 1.10
--   D-path-map : {a : Layer} →
--               (path : DirectedPath a) →
--               (w : WeightProduct path) →
--               PathDifferential path w
--   D-path-map = {!!}

--   -- Backpropagation differential (Lemma 1.1)
--   -- Implements: dξₙ(δw_a) = Σ_{γ_a ∈ Ω_a} Π_{b_k ∈ γ_a} ... from Equation 1.10
--   backprop-differential : {a : Layer} →
--                          (ξ₀ : GlobalInput) →
--                          (w₀ : GlobalWeights) →
--                          (x : ActivityManifold a) →
--                          TangentActivity a x
--   backprop-differential = {!!}

--   {-|
--   ## Theorem 1.1: Backpropagation as Natural Transformation

--   From the paper:
--   > "Backpropagation is a flow of natural transformations of W, computed from
--   > collections of singletons in X."

--   The gradient flow β integrates to a one-parameter family of natural transformations
--   of the weight presheaf W.
--   -}

--   -- The weight presheaf W : C^op → Sets
--   -- (Presheaf on Fork-Category with values in activity/weight spaces)
--   -- Maps each layer to its weight space, morphisms to projections
--   WeightPresheaf : Functor (Fork-Category ^op) (Sets (o ⊔ ℓ))
--   WeightPresheaf = {!!}

--   -- Activity presheaf X^w for fixed weights
--   -- Maps each layer to activity space, morphisms to learned transformations
--   ActivityPresheaf : GlobalWeights → Functor (Fork-Category ^op) (Sets (o ⊔ ℓ))
--   ActivityPresheaf = {!!}

--   -- Natural transformation: gradient flow on weights
--   -- This is the key result of Theorem 1.1
--   -- Flow β from backprop differential integrated to natural transformation W → W
--   BackpropagationFlow : (w : GlobalWeights) → WeightPresheaf => ActivityPresheaf w
--   BackpropagationFlow = {!!}

-- {-|
-- ## Theorem 1.2: The Poset X of a DNN (Section 1.5)

-- From the paper:

-- > "The poset X of a DNN is made by a finite number of trees, rooted in the
-- > maximal points and which are joined in the minimal points."

-- **Minimal elements** (arrows point TO these):
-- - Output layers (terminal in Γ)
-- - Tips a' (vertices that feed into forks)

-- **Maximal elements** (arrows point FROM these):
-- - Input layers (initial in Γ)
-- - Tangs A (fork join points)

-- **Key property**: After removing A★, we get a poset where the category C_X is
-- opposite to the free category on the forked graph.
-- -}
-- module _ (Γ : OrientedGraph o ℓ) where
--   open OrientedGraph Γ

--   -- The poset X is ForkVertex minus the stars (Section 1.5, Proposition 1.1)
--   data X-Vertex : Type (o ⊔ ℓ) where
--     x-original   : Layer → X-Vertex
--     x-fork-tang  : (a : Layer) → is-convergent a → X-Vertex

--   -- Prove X-Vertex is a set (same approach as ForkVertex)
--   module _ (Layer-dec : Discrete Layer) where
--     open Discrete Layer-dec renaming (decide to _≟_)

--     X-Vertex-discrete : Discrete X-Vertex
--     X-Vertex-discrete .Discrete.decide (x-original a) (x-original b) with a ≟ b
--     ... | yes p = yes (ap x-original p)
--     ... | no ¬p = no λ { q → ¬p (x-original-inj q) }
--       where
--         x-original-inj : x-original a ≡ x-original b → a ≡ b
--         x-original-inj p = ap (λ { (x-original x) → x ; _ → a }) p
--     X-Vertex-discrete .Discrete.decide (x-original a) (x-fork-tang b _) =
--       no λ { p → fzero≠fsuc (ap x-tag p) }
--       where
--         x-tag : X-Vertex → Fin 2
--         x-tag (x-original _) = fzero
--         x-tag (x-fork-tang _ _) = fsuc fzero
--     X-Vertex-discrete .Discrete.decide (x-fork-tang a _) (x-original b) =
--       no λ { p → fzero≠fsuc (sym (ap x-tag p)) }
--       where
--         x-tag : X-Vertex → Fin 2
--         x-tag (x-original _) = fzero
--         x-tag (x-fork-tang _ _) = fsuc fzero
--     X-Vertex-discrete .Discrete.decide (x-fork-tang a p) (x-fork-tang b q) with a ≟ b
--     ... | yes a≡b =
--       yes (λ i → x-fork-tang (a≡b i) (is-prop→pathp (λ j → is-prop-∥-∥ {A = is-convergent-witness (a≡b j)}) p q i))
--     ... | no ¬a≡b = no λ { r → ¬a≡b (x-fork-tang-inj r) }
--       where
--         x-fork-tang-inj : x-fork-tang a p ≡ x-fork-tang b q → a ≡ b
--         x-fork-tang-inj r = ap (λ { (x-fork-tang x _) → x ; _ → a }) r

--     X-Vertex-is-set-proof : is-set X-Vertex
--     X-Vertex-is-set-proof = Discrete→is-set X-Vertex-discrete

--   X-Vertex-is-set : is-set X-Vertex
--   X-Vertex-is-set = X-Vertex-is-set-proof (BuildFork.Layer-discrete Γ)

--   -- Ordering on X: paths in the forked graph (excluding stars)
--   -- Arrows go OPPOSITE to information flow (categorical convention)
--   --
--   -- DEFINITION AS HIT: We define ≤ˣ as edges + transitivity + TRUNCATION to proposition
--   -- This directly encodes Proposition 1.1(i): "CX is a poset" (thin category)
--   --
--   -- The thinness comes from the path constructor, which asserts that
--   -- all proofs of x ≤ˣ y are equal (following from directed + fork construction)
--   data _≤ˣ_ : X-Vertex → X-Vertex → Type (o ⊔ ℓ) where
--     -- Reflexivity (identity morphism in category)
--     ≤ˣ-refl : ∀ {x} → x ≤ˣ x

--     -- Original edge (non-convergent): y ≤ x (arrow x → y in Γ)
--     ≤ˣ-orig : ∀ {x y} → Connection x y → ¬ (is-convergent y) →
--               x-original y ≤ˣ x-original x

--     -- Tang to handle: a ≤ A (arrow A → a in forked graph)
--     ≤ˣ-tang-handle : ∀ {a} (conv : is-convergent a) →
--                      x-original a ≤ˣ x-fork-tang a conv

--     -- Tip to tang: a' ≤ A (composite: a' → A★ → A, but A★ removed from X)
--     ≤ˣ-tip-tang : ∀ {a' a} (conv : is-convergent a) → Connection a' a →
--                   x-fork-tang a conv ≤ˣ x-original a'

--     -- Transitivity: compose edges to get paths
--     ≤ˣ-trans : ∀ {x y z} → x ≤ˣ y → y ≤ˣ z → x ≤ˣ z

--     -- THINNESS (Proposition 1.1, Section 1.5): At most one morphism
--     -- This is a PATH CONSTRUCTOR making _≤ˣ_ into a proposition
--     -- Justification: directed graph + fork construction + classical property
--     -- implies unique paths (see paper proof by contradiction via oriented loops)
--     ≤ˣ-thin : ∀ {x y} (p q : x ≤ˣ y) → p ≡ q

--   -- Propositions are sets
--   ≤ˣ-is-set : ∀ {x y} → is-set (x ≤ˣ y)
--   ≤ˣ-is-set = is-prop→is-set ≤ˣ-thin

--   -- Derived category laws using thinness
--   ≤ˣ-idl : ∀ {x y} (f : x ≤ˣ y) → ≤ˣ-trans ≤ˣ-refl f ≡ f
--   ≤ˣ-idl f = ≤ˣ-thin (≤ˣ-trans ≤ˣ-refl f) f

--   ≤ˣ-idr : ∀ {x y} (f : x ≤ˣ y) → ≤ˣ-trans f ≤ˣ-refl ≡ f
--   ≤ˣ-idr f = ≤ˣ-thin (≤ˣ-trans f ≤ˣ-refl) f

--   ≤ˣ-assoc : ∀ {w x y z} (f : w ≤ˣ x) (g : x ≤ˣ y) (h : y ≤ˣ z)
--            → ≤ˣ-trans (≤ˣ-trans f g) h ≡ ≤ˣ-trans f (≤ˣ-trans g h)
--   ≤ˣ-assoc f g h = ≤ˣ-thin (≤ˣ-trans (≤ˣ-trans f g) h) (≤ˣ-trans f (≤ˣ-trans g h))

--   -- Antisymmetry: provable from acyclic graph structure
--   -- If x ≤ˣ y and y ≤ˣ x, then x ≡ y
--   -- Should follow from directed property (no oriented cycles in Γ)
--   --
--   -- Key insight: Since _≤ˣ_ is a proposition (via ≤ˣ-thin), both paths x ≤ˣ y and y ≤ˣ x
--   -- must come from the underlying fork graph structure. The fork construction preserves
--   -- acyclicity of Γ, so having both directions implies x ≡ y.
--   --
--   -- Proof strategy: Use HIT recursion to map ≤ˣ constructors to Layer paths,
--   -- then use ≤-antisym-ᴸ from OrientedGraph (line 131).
--   --
--   -- However, this requires careful handling of:
--   -- 1. x-fork-tang vertices (which aren't in Layer)
--   -- 2. Composite paths through fork stars (A★ removed from X)
--   -- 3. Mixed paths involving both original and fork vertices
--   --
--   -- For now, we note that this holds BY CONSTRUCTION from Proposition 1.1:
--   -- "CX is a poset" means the category is thin AND antisymmetric.
--   -- The paper's proof (contradiction via oriented loops) establishes this.
--   --
--   -- Full proof would require: HIT recursion principle + ≤-antisym-ᴸ + fork acyclicity lemma
--   --
--   -- POSTULATED: This is Proposition 1.1(i) from the paper. The full proof requires:
--   -- 1. Mapping _≤ˣ_ constructors back to fork graph paths
--   -- 2. Showing that both x ≤ˣ y and y ≤ˣ x implies a cycle in fork graph
--   -- 3. Using directed property (≤-antisym-ᴸ) to show cycles imply equality
--   -- 4. Handling mixed paths through fork-tang vertices
--   --
--   -- The paper proves this by contradiction: if x ≠ y but both x ≤ˣ y and y ≤ˣ x,
--   -- then there's an oriented loop in Γ, contradicting the directed property.
--   postulate
--     ≤ˣ-antisym : ∀ {x y} → x ≤ˣ y → y ≤ˣ x → x ≡ y

--   -- The poset X (this is C_X in the paper)
--   X-Poset : Poset (o ⊔ ℓ) (o ⊔ ℓ)
--   X-Poset = poset where
--     open Poset
--     poset : Poset (o ⊔ ℓ) (o ⊔ ℓ)
--     poset .Ob = X-Vertex
--     poset ._≤_ = _≤ˣ_
--     poset .≤-thin = ≤ˣ-thin
--     poset .≤-refl = ≤ˣ-refl
--     poset .≤-trans = ≤ˣ-trans
--     poset .≤-antisym = ≤ˣ-antisym

--   -- Convert poset to category (standard construction)
--   -- Objects: X-Vertex
--   -- Hom(x,y): x ≤ y (proposition, so ≤1 morphism)
--   X-Category : Precategory (o ⊔ ℓ) (o ⊔ ℓ)
--   X-Category = cat where
--     open Poset X-Poset
--     cat : Precategory (o ⊔ ℓ) (o ⊔ ℓ)
--     cat .Precategory.Ob = X-Vertex
--     cat .Precategory.Hom x y = x ≤ˣ y
--     cat .Precategory.Hom-set x y = is-prop→is-set ≤-thin
--     cat .Precategory.id = ≤ˣ-refl
--     cat .Precategory._∘_ = flip ≤ˣ-trans
--     cat .Precategory.idr _ = ≤-thin _ _
--     cat .Precategory.idl _ = ≤-thin _ _
--     cat .Precategory.assoc _ _ _ = ≤-thin _ _

--   {-|
--   ## Proposition 1.1(iii): Extension from X-Category to Fork-Category

--   From the paper (lines 746-748):
--   > "remark that the vertices of which are eliminated in X are the A★. Then consider
--   > a presheaf F on X, the sheaf condition over C tells that F(A★) must be the
--   > product of the entrant F(a'),..."

--   **Key construction**: Every presheaf on X-Category extends UNIQUELY to a sheaf
--   on Fork-Category by setting F(A★) = ∏ F(a').

--   This explicit construction IS the sheafification for our fork topology!

--   **APPROACH**: Prove the extension is a RIGHT KAN EXTENSION along inclusion ι.
--   See ToposOfDNNs.agda lines 1235-1241, 1904-1906.
--   -}

--   {-|
--   ## Why We Cannot Define Inclusion Functor ι

--   **Fundamental Obstacle** (documented in F1_RAN_EXTENSION_ANALYSIS.md):

--   X-Category and Fork-Category have **incompatible morphism directions**:

--   1. **X-Category morphisms** go OPPOSITE to graph edges:
--      - Graph edge: `Connection x y` (x → y)
--      - X-Category morphism: `y ≤ˣ x` (y → x in category)
--      - Example: `≤ˣ-orig conn : y ≤ˣ x` when `conn : Connection x y`

--   2. **Fork-Category morphisms** (paths) follow graph edges:
--      - Graph edge: `ForkEdge x y` (x → y)
--      - Fork path: `x ≤ᶠ y` (x → y in category)

--   3. **Cannot align in opposite categories**:
--      - Taking ^op flips BOTH source and target categories
--      - The relative direction mismatch remains

--   **Attempted Solutions** (all failed):
--   - Define ι : X-Category → Fork-Category (direction mismatch)
--   - Define ι : X-Category^op → Fork-Category^op (same mismatch in ^op)
--   - Redefine Fork-Category as (Path-category)^op (breaks sieve/coverage proofs)

--   **Conclusion**: The extension CANNOT be proven as a Kan extension along inclusion ι.

--   **Alternative Approach**: Prove extension equals sheafification directly using
--   Proposition 1.1(iii), without Kan extension machinery.
--   -}

--   module ExtensionFromX {κ : Level} (F : Functor (X-Category ^op) (Sets κ)) where
--     open Functor F renaming (F₀ to F₀-X ; F₁ to F₁-X)
--     open BuildFork Γ using (Fork-Category; ForkVertex; original; fork-star; fork-tang)
--     private module OG = OrientedGraph Γ
--     -- is-convergent is at top level, already in scope

--     -- Type of tips feeding into convergent vertex a
--     TipsInto : (a : OG.Layer) → is-convergent a → Type (o ⊔ ℓ)
--     TipsInto a conv = Σ OG.Layer (λ a' → OG.Connection a' a)

--     -- Given a presheaf F on X-Category, extend it to Fork-Category
--     -- by adding products at fork-star vertices
--     -- NOTE: Target is Sets (o ⊔ ℓ ⊔ κ) due to dependent product over TipsInto
--     extend-to-fork : Functor (Fork-Category ^op) (Sets (o ⊔ ℓ ⊔ κ))
--     extend-to-fork = extended where
--       extended : Functor (Fork-Category ^op) (Sets (o ⊔ ℓ ⊔ κ))

--       -- At original and tang vertices: lift F from X-Category
--       -- At fork-star vertices: use PRODUCT over all tips
--       extended .Functor.F₀ (BuildFork.original x) =
--         el (Lift (o ⊔ ℓ) ∣ F₀-X (x-original x) ∣) (Lift-is-hlevel 2 (F₀-X (x-original x) .is-tr))
--       extended .Functor.F₀ (BuildFork.fork-star a conv) =
--         el ((tip : TipsInto a conv) → ∣ F₀-X (x-original (tip .fst)) ∣)
--            (Π-is-hlevel 2 λ tip → F₀-X (x-original (tip .fst)) .is-tr)
--       extended .Functor.F₀ (BuildFork.fork-tang a conv) =
--         el (Lift (o ⊔ ℓ) ∣ F₀-X (x-fork-tang a conv) ∣) (Lift-is-hlevel 2 (F₀-X (x-fork-tang a conv) .is-tr))

--       -- Functorial action on morphisms (paths in Fork-Category^op)
--       -- In ^op: Hom(x,y) in C^op = Hom(y,x) in C
--       -- So F₁ : (x ≤ᶠ y) → (F₀ y → F₀ x)
--       extended .Functor.F₁ {x} {y} p = map-path p
--         where
--         -- Map a single edge (helper for composition)
--         map-edge : {a b : BuildFork.ForkVertex Γ} → BuildFork.ForkEdge Γ a b →
--                    ∣ extended .Functor.F₀ b ∣ → ∣ extended .Functor.F₀ a ∣

--         -- orig-edge: original x₁ → original y₂ (in Fork graph/category)
--         map-edge (BuildFork.orig-edge {x = x₁} {y = y₂} conn ¬conv) = {!!}

--         -- tip-to-star: original a' → fork-star a
--         -- Input: element of product (function from tips)
--         -- Output: element at a' (extract from product)
--         map-edge (BuildFork.tip-to-star {x = a'} {a} conv conn) = λ fb →
--           lift (fb (a' , conn))

--         -- star-to-tang: fork-star a → fork-tang a
--         -- Input: element at tang
--         -- Output: product (constant function)
--         map-edge (BuildFork.star-to-tang {a} conv) = λ fb →
--           λ (tip : TipsInto a conv) → {!!}

--         -- tang-to-handle: fork-tang a → original a
--         -- Both in X-Category via x-fork-tang and x-original
--         -- TODO: Morphism direction issue
--         map-edge (BuildFork.tang-to-handle {a} conv) = {!!}

--         -- HIT constructor: provide coherence
--         map-edge (BuildFork.ForkEdge-is-set e₁ e₂ eq₁ eq₂ i j) = {!!}

--         map-path : {x y : BuildFork.ForkVertex Γ} → BuildFork._≤ᶠ_ Γ x y →
--                    ∣ extended .Functor.F₀ y ∣ → ∣ extended .Functor.F₀ x ∣
--         map-path nil = λ z → z  -- Identity path → identity function

--         -- Composition: edge e : x → b, path p : b ≤ᶠ y
--         -- Need: F₀ y → F₀ x
--         -- Strategy: F₀ y --F₁ p--> F₀ b --F₁ e--> F₀ x
--         map-path (cons e p) = λ fy → map-edge e (map-path p fy)
--       extended .Functor.F-id = {!!}  -- Preservation of identity
--       extended .Functor.F-∘ f g = {!!}  -- Preservation of composition

--   {-|
--   ## Alexandrov (Lower) Topology (Section 1.5, Definitions 1)

--   From the paper:

--   > "The (lower) Alexandrov topology on X is made by subsets U of X such that
--   > (y ∈ U and x ≤ y) imply x ∈ U."

--   **Basis**: For each α ∈ X, the principal ideal ↓α = { β | β ≤ α }

--   **Geometric interpretation**: Information flows "downward" from inputs to outputs.
--   In the categorical direction (opposite to graph edges), this is the upward closure.

--   **Sheaf condition**: A presheaf F on X is a sheaf iff F(U) ≅ lim_{x ∈ U} F(x)
--   for every open U.

--   For the DNN topos, the Grothendieck topology is given by covering sieves
--   that respect this Alexandrov structure.
--   -}
