{-# OPTIONS --no-import-sorts #-}
{-|
# The Poset X of a DNN (Section 1.5, Proposition 1.1)

**Reference**: Belfiore & Bennequin (2022), Section 1.5
arXiv:2106.14587v3 [math.AT]

## Main Results:

**Proposition 1.1**:
(i) CX is a poset
(ii) Every presheaf on C induces a presheaf on CX
(iii) For every presheaf on CX, there exists a unique sheaf on C which induces it

**Corollary**: C∼ is naturally equivalent to the category of presheaves C∧_X

## The Construction:

From the paper:
> "X denotes the set of vertices of the full subcategory CX of C generated by X,
> of type a or of type A (see figure 1.2)."

We remove the A★ (fork-star) vertices from the fork category C to get the poset X = CX.
The key insight is that removing A★ breaks any potential cycles that could arise from
the fork structure, making CX a proper poset.

## Ordering:

From the paper:
> "If x, y belong to X, we note x ≤ y when there exists a morphism from x to y;
> then it is equivalent to write x → y in the category CX."

In our convention (information flows opposite to categorical arrows):
- y ≤ x when there's a path from x to y in the original graph Γ
- Minimal elements: outputs + tips (information sinks)
- Maximal elements: inputs + tangs (information sources)
-}

module Neural.Topos.Poset where

open import 1Lab.Prelude
open import 1Lab.HLevel
open import 1Lab.Path

open import Cat.Base
open import Cat.Instances.Functor
open import Cat.Functor.Base
open import Cat.Site.Base using (Coverage; is-sheaf)
open import Cat.Diagram.Sieve

open import Order.Base using (Poset)
open import Order.Cat using (poset→category)

open import Data.Nat.Base using (Nat; zero; suc)
open import Data.Power

open import Neural.Topos.Architecture
open import Neural.Topos.Category

private variable
  o ℓ : Level

{-|
## Removing Fork-Star Vertices (Definition of X)

The poset X is obtained from the fork category C by removing all A★ vertices.
From Architecture.agda, we have ForkVertex with three constructors:
- original: Vertex → ForkVertex
- fork-star: (convergent vertex) → ForkVertex  [REMOVED in X]
- fork-tang: (convergent vertex) → ForkVertex

We keep only `original` and `fork-tang` vertices.
-}
module PosetOfGraph (Γ : OrientedGraph o ℓ) where
  open OrientedGraph Γ

  {-|
  ### X-Vertex: Vertices without fork-stars

  This is the same as X-Vertex from Architecture.agda, but we re-declare it here
  to emphasize that it's the fundamental object of study in this module.
  -}
  data X-Vertex : Type (o ⊔ ℓ) where
    x-original   : Vertex → X-Vertex
    x-fork-tang  : (a : Vertex) → is-convergent Γ a → X-Vertex

  {-|
  ### Ordering on X

  From the paper's proof of Proposition 1.1(i):
  > "let γ₁, γ₂ be two different simple directed paths in CX going from a point z
  > in X to a point x in X..."

  The ordering is given by paths in the forked graph, excluding paths through A★.
  Arrows go OPPOSITE to information flow (categorical convention).
  -}
  data _≤ˣ_ : X-Vertex → X-Vertex → Type (o ⊔ ℓ) where
    -- Reflexivity
    ≤ˣ-refl : ∀ {x} → x ≤ˣ x

    -- Original edge (non-convergent): x ≤ y (when Edge x y in Γ)
    -- Arrows go in SAME direction as edges (categorical convention)
    ≤ˣ-orig : ∀ {x y} → Edge x y → ¬ (is-convergent Γ y) →
              x-original x ≤ˣ x-original y

    -- Tang to handle: A ≤ a (when there's an edge into a convergent vertex a)
    -- In Fork-Cat: fork-tang a → original a
    ≤ˣ-tang-handle : ∀ {a} (conv : is-convergent Γ a) →
                     x-fork-tang a conv ≤ˣ x-original a

    -- Tip to tang: a' ≤ A (when Edge a' a where a is convergent)
    -- This jumps over the removed A★: a' → A★ → A becomes a' → A
    ≤ˣ-tip-tang : ∀ {a' a} (conv : is-convergent Γ a) → Edge a' a →
                  x-original a' ≤ˣ x-fork-tang a conv

    -- Transitivity
    ≤ˣ-trans : ∀ {x y z} → x ≤ˣ y → y ≤ˣ z → x ≤ˣ z

  {-|
  ## Proposition 1.1(i): CX is a Poset

  **Proof sketch from paper**:
  The key is to show antisymmetry: if x ≤ y and y ≤ x, then x = y.

  From the paper:
  > "let γ₁, γ₂ be two different simple directed paths in CX going from a point z
  > in X to a point x in X, there must exists a first point y where the two paths
  > disjoin, going to two different points y₁, y₂."

  The proof proceeds by contradiction:
  1. Assume x ≤ y and y ≤ x with x ≠ y
  2. There exist paths γ₁: x → y and γ₂: y → x
  3. These paths must diverge and reconverge, creating a potential cycle
  4. Analysis of fork structure shows this is impossible:
     - y cannot be a handle (type a) - it has unique predecessor
     - y cannot be input or tang - they are sources
     - y must be output or tip
  5. At divergence point, one branch must go through a tang A
  6. But then both paths would need to converge at same tang A
  7. This would create oriented loop in original graph Γ
  8. Contradiction with Γ being directed (acyclic)

  Therefore CX is antisymmetric and hence a poset.
  -}

  postulate
    -- These are deep properties that require careful analysis of the fork structure
    ≤ˣ-thin : ∀ {x y} → is-prop (x ≤ˣ y)
    ≤ˣ-antisym : ∀ {x y} → x ≤ˣ y → y ≤ˣ x → x ≡ y

  {-|
  ### X-Poset: The fundamental poset structure

  This is the poset X from the paper. It has the structure:
  - **Minimal elements** (where arrows terminate):
    - Outputs: is-output
    - Tips: vertices feeding into forks
  - **Maximal elements** (where arrows originate):
    - Inputs: is-input
    - Tangs: fork join points (type A)
  -}
  X-Poset : Poset (o ⊔ ℓ) (o ⊔ ℓ)
  X-Poset = poset where
    open Poset
    poset : Poset (o ⊔ ℓ) (o ⊔ ℓ)
    poset .Ob = X-Vertex
    poset ._≤_ = _≤ˣ_
    poset .≤-thin = ≤ˣ-thin
    poset .≤-refl = ≤ˣ-refl
    poset .≤-trans = ≤ˣ-trans
    poset .≤-antisym = ≤ˣ-antisym

  {-|
  ### CX-Category: The poset as a category

  From the paper:
  > "we note x ≤ y when there exists a morphism from x to y"

  This gives us a category where:
  - Objects: X-Vertex
  - Hom(x,y): x ≤ y (a proposition, so at most one morphism)
  - Composition: transitivity of ≤
  -}
  CX-Category : Precategory (o ⊔ ℓ) (o ⊔ ℓ)
  CX-Category = poset→category X-Poset

  {-|
  ## Proposition 1.1(ii): Presheaf Restriction

  From the paper:
  > "Every presheaf on C induces a presheaf on CX."

  This is straightforward: we simply restrict a presheaf F: C^op → Sets
  to the subcategory CX ⊂ C.

  The functor F(A★) at fork-star vertices is ignored, and we keep only:
  - F(a) for original vertices
  - F(A) for tang vertices
  -}

  module _ (ForkVertex-is-set : is-set (ForkConstruction.ForkVertex Γ)) where
    open Functor
    open ForkConstruction Γ using (ForkVertex; fork-star; original; fork-tang; _≤ᶠ_; module _≤ᶠ_)

    -- Use the Fork-Category from Neural.Topos.Category
    Fork-Cat : Precategory (o ⊔ ℓ) (o ⊔ ℓ)
    Fork-Cat = ForkConstruction.Fork-Category Γ ForkVertex-is-set

    -- The inclusion functor ι: CX ↪ Fork-Cat
    -- Maps X-Vertex to ForkVertex (excludes fork-stars)
    {-# TERMINATING #-}
    ι-CX : Functor CX-Category Fork-Cat
    ι-CX .F₀ (x-original v) = original v
    ι-CX .F₀ (x-fork-tang a conv) = fork-tang a conv
    ι-CX .F₁ ≤ˣ-refl = _≤ᶠ_.id-edge
    -- ≤ˣ-orig : Edge x y → x-original x ≤ˣ x-original y
    -- orig-edge : Edge x y → original x ≤ᶠ original y
    -- Perfect match!
    ι-CX .F₁ (≤ˣ-orig e not-conv) = _≤ᶠ_.orig-edge e not-conv
    -- ≤ˣ-tang-handle : fork-tang a → original a
    -- tang-to-handle : fork-tang a → original a
    ι-CX .F₁ (≤ˣ-tang-handle conv) = _≤ᶠ_.tang-to-handle conv
    -- ≤ˣ-tip-tang : Edge a' a → original a' ≤ˣ fork-tang a
    -- Need: original a' ≤ᶠ fork-tang a
    -- Path: original a' → fork-star a → fork-tang a
    ι-CX .F₁ (≤ˣ-tip-tang conv e) =
      _≤ᶠ_.≤ᶠ-trans (_≤ᶠ_.star-to-tang conv) (_≤ᶠ_.tip-to-star conv e)
    -- ≤ˣ-trans : (x ≤ˣ y) → (y ≤ˣ z) → (x ≤ˣ z) [sequential]
    -- ≤ᶠ-trans : (y ≤ᶠ z) → (x ≤ᶠ y) → (x ≤ᶠ z) [diagrammatic]
    -- So map ≤ˣ-trans f g to ≤ᶠ-trans (F₁ g) (F₁ f)
    ι-CX .F₁ (≤ˣ-trans f g) = _≤ᶠ_.≤ᶠ-trans (ι-CX .F₁ g) (ι-CX .F₁ f)
    ι-CX .F-id = refl  -- F₁ ≤ˣ-refl = id-edge = id
    ι-CX .F-∘ f g = refl  -- F₁ (≤ˣ-trans f g) = ≤ᶠ-trans (F₁ g) (F₁ f) = F₁ g ∘ F₁ f

    {-|
    Restriction of a presheaf on C to CX.
    Given F: C^op → Sets, we get F|_CX : CX^op → Sets via precomposition.
    -}
    presheaf-restriction : ∀ {κ} →
                          Functor (Fork-Cat ^op) (Sets κ) →
                          Functor (CX-Category ^op) (Sets κ)
    presheaf-restriction F = F F∘ Functor.op ι-CX

  {-|
  ## Proposition 1.1(iii): Unique Sheaf Extension

  From the paper's proof:
  > "remark that the vertices which are eliminated in X are the A★. Then consider
  > a presheaf F on X, the sheaf condition over C tells that F(A★) must be the
  > product of the entrant F(a'), ..., then the product map F(A) → F(A★) of the
  > maps F(A) → F(a') gives a sheaf."

  **Key insight**: At each fork with star A★:
  - A★ has incoming arrows from tips a', a'', ...
  - A★ has outgoing arrow to tang A
  - The sheaf condition forces: F(A★) ≅ ∏_{a'→A★} F(a')
  - Since F is given on CX, we have F(a') and F(A)
  - We define F(A★) := ∏ F(a') to satisfy the sheaf condition
  - The maps F(A) → F(a') (induced by A → A★ → a') give the extension

  This extension is unique because:
  1. The sheaf condition uniquely determines F(A★)
  2. The morphism structure is uniquely determined by composition in C
  -}

    -- Presheaf restriction (re-use definition from above)
    presheaf-restriction' : ∀ {κ} → Functor (Fork-Cat ^op) (Sets κ) → Functor (CX-Category ^op) (Sets κ)
    presheaf-restriction' = presheaf-restriction

    {-|
    ### Fork Coverage: The Grothendieck topology J

    From the paper's proof of Proposition 1.1(iii):
    > "the sheaf condition over C tells that F(A★) must be the product of
    > the entrant F(a'), ..."

    The fork topology has different coverings depending on vertex type:
    - **At fork-star A★**: Covering = all incoming edges from tips
      - This encodes the sheaf gluing condition F(A★) ≅ ∏_{a'→A★} F(a')
    - **At other vertices**: Maximal sieve (all morphisms)
      - No special gluing condition needed
    -}
    fork-coverage : ∀ {κ} → Coverage Fork-Cat κ
    fork-coverage {κ} = cov where
      open Coverage
      open Sieve

      -- For each vertex, define what it means to be a covering
      covers-vertex : ForkVertex → Type κ
      covers-vertex (fork-star a conv) = Lift κ ⊤  -- fork-stars have one canonical covering
      covers-vertex _ = Lift κ ⊤  -- all other vertices use maximal sieve

      -- Convert covering to sieve
      cover-sieve : ∀ {v : ForkVertex} → covers-vertex v → Sieve Fork-Cat v
      cover-sieve {fork-star a conv} (lift tt) = record
        { arrows = λ {y} f → el ⊤ (λ _ _ → refl)
          -- At A★, include ALL incoming morphisms (tips, but also any path leading to A★)
        ; closed = λ hf g → tt
        }
      cover-sieve {original x} (lift tt) = maximal' {C = Fork-Cat}
      cover-sieve {fork-tang a conv} (lift tt) = maximal' {C = Fork-Cat}

      -- Stability: pullbacks of coverings are coverings
      -- For fork topology, maximal sieves pull back to maximal sieves
      -- For fork-star sieves (all arrows), pullback is also all arrows
      -- Since all our sieves have arrows : f → el ⊤ _, the pullback also has ⊤
      stability : ∀ {U V : ForkVertex} (R : covers-vertex U) (f : Fork-Cat .Precategory.Hom V U)
                → ∃[ S ∈ covers-vertex V ] (cover-sieve S ⊆ pullback {C = Fork-Cat} f (cover-sieve R))
      stability {fork-star a conv} {fork-star b conv'} (lift tt) f = inc (lift tt , λ h _ → tt)
      stability {fork-star a conv} {original v} (lift tt) f = inc (lift tt , λ h _ → tt)
      stability {fork-star a conv} {fork-tang b conv'} (lift tt) f = inc (lift tt , λ h _ → tt)
      stability {original u} {fork-star b conv'} (lift tt) f = inc (lift tt , λ h _ → tt)
      stability {original u} {original v} (lift tt) f = inc (lift tt , λ h _ → tt)
      stability {original u} {fork-tang b conv'} (lift tt) f = inc (lift tt , λ h _ → tt)
      stability {fork-tang a conv} {fork-star b conv'} (lift tt) f = inc (lift tt , λ h _ → tt)
      stability {fork-tang a conv} {original v} (lift tt) f = inc (lift tt , λ h _ → tt)
      stability {fork-tang a conv} {fork-tang b conv'} (lift tt) f = inc (lift tt , λ h _ → tt)

      cov : Coverage Fork-Cat κ
      cov .covers = covers-vertex
      cov .cover = cover-sieve
      cov .stable = stability

    {-|
    For each presheaf F on CX, there exists a unique extension to a sheaf on C.
    The sheaf is characterized by:
    - F̃(x) = F(x) for x ∈ CX
    - F̃(A★) = ∏_{a'→A★} F(a') for fork-stars
    - Sheaf condition: F̃ satisfies gluing for the fork topology J
    -}
    postulate
      sheaf-extension : ∀ {κ} (F : Functor (CX-Category ^op) (Sets κ)) →
                       Σ[ F̃ ∈ Functor (Fork-Cat ^op) (Sets κ) ]
                         ((presheaf-restriction' F̃ ≡ F) × is-sheaf (fork-coverage {κ}) F̃)

      {-|
      The extension is unique: if two sheaves F̃₁ and F̃₂ both extend F: CX → Sets
      and satisfy the sheaf condition, then F̃₁ ≡ F̃₂.
      -}
      sheaf-extension-unique : ∀ {κ} {F : Functor (CX-Category ^op) (Sets κ)} →
                              (ext₁ ext₂ : Σ[ F̃ ∈ Functor (Fork-Cat ^op) (Sets κ) ]
                                             ((presheaf-restriction' F̃ ≡ F) × is-sheaf (fork-coverage {κ}) F̃)) →
                              ext₁ ≡ ext₂

  {-|
  ## Corollary: Equivalence of Categories

  From the paper:
  > "Corollary. C∼ is naturally equivalent to the category of presheaves C∧_X."

  Where:
  - C∼ = Sh[C, J] is the topos of sheaves on (C, J) with fork topology J
  - C∧_X = [CX^op, Sets] is the category of presheaves on the poset CX

  This follows from Proposition 1.1(iii): the sheaf extension gives a functor
  [CX^op, Sets] → Sh[C, J] that is an equivalence of categories.

  **Intuition**: The fork-stars A★ are "redundant" - they exist only to encode
  the sheaf gluing condition. Once we remove them to get CX, presheaves on CX
  are equivalent to sheaves on C because the sheaf condition at A★ is automatic
  (forced by the structure).
  -}
  postulate
    topos-presheaf-equivalence : ∀ {κ} →
      -- Sh[C, J] ≃ [CX^op, Sets]
      -- This requires defining the sheaf topos, which we do in Properties.agda
      Type (o ⊔ ℓ ⊔ lsuc κ)

{-|
## Summary

This module establishes the fundamental poset structure X = CX:

1. **Construction**: Remove fork-star vertices A★ from fork category C
2. **Ordering**: Paths in forked graph (arrows opposite to information flow)
3. **Proposition 1.1(i)**: X is a poset (antisymmetric by acyclicity of Γ)
4. **Proposition 1.1(ii)**: Presheaves on C restrict to CX
5. **Proposition 1.1(iii)**: Presheaves on CX extend uniquely to sheaves on C
6. **Corollary**: Sh[C, J] ≃ [CX^op, Sets]

This is the foundation for understanding DNNs as topoi: the complicated fork
structure with A★ vertices is equivalent to the simpler poset structure X,
but presheaves must be replaced by sheaves to capture the gluing at convergence
points.

**Next steps** (in Alexandrov.agda):
- Define the Alexandrov (lower) topology on X
- Show that sheaves on (X, Alexandrov) are equivalent to presheaves on X
- Establish the full topos structure
-}
