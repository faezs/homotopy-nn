{-|
# The Poset X and Future Topos Structure

This module implements the poset X from Section 1.5 (Proposition 1.1) of
Belfiore & Bennequin (2022).

## Mathematical Context

**The construction**:
- Start with fork graph Γ̄ (oriented, with A★ vertices)
- Define X by excluding A★ vertices
- X inherits orientation from Γ̄
- X forms a poset (Proposition 1.1(i))

**Connection to Topos Theory**:

From the paper (lines 568-571):
> "It is remarkable that the main structural part... can be interpreted
> by the fact that the presheaf is a sheaf for a natural Grothendieck
> topology J on the category C: in every object x of C the only covering
> is the full category C|x, except when x is of the type of A★, where we
> add the covering made by the arrows of the type a' → A★."

**Key equivalences** (implemented in future ForkTopos.agda):
- **Corollary (line 749)**: DNN-Topos ≃ PSh(X)
- **Corollary (line 791)**: DNN-Topos ≃ Sh-Alexandrov(X)

Where:
- DNN-Topos = Sh[Γ̄, fork-topology]
- fork-topology has special coverage at A★ vertices
- Sheaf condition: F(A★) ≅ ∏_{a'→A★} F(a')

## This Module (Phase 3-5)

Implements:
1. **Phase 3**: X via subgraph classifier Ωᴳ
2. **Phase 4**: X-oriented (inheritance from Γ̄)
3. **Phase 5**: X-Poset and X-Category

**Future work**: See ForkTopos.agda (Phase 6) for full topos construction.

-}

module Neural.Graph.ForkPoset where

open import Neural.Graph.ForkCategorical
open import Neural.Graph.Oriented
open import Neural.Graph.Path

open import Cat.Instances.Graphs
open import Cat.Instances.Graphs.Omega
open import Cat.Instances.Graphs.Limits
open import Cat.Base  -- For Precategory

open import Order.Base

open import 1Lab.Prelude
open import 1Lab.HLevel

open import Data.List hiding (_++_; ++-idr; ++-assoc)  -- Hide list ops to avoid ambiguity with path ops
open import Data.Dec.Base

private variable
  o ℓ : Level

{-|
## Phase 3: Defining X via Subgraph Classifier

X is defined as the pullback of the characteristic morphism classifying
non-star vertices along the true morphism into Ωᴳ.

**From the paper** (line 716):
> "Let X denotes the set of vertices of the full subcategory CX of C
> generated by X of type a or of type A."

In our formalization:
- Type a = v-original vertices
- Type A = v-fork-tang vertices
- Excluded: v-fork-star vertices (A★)
-}

module _ (G : Graph o ℓ)
         (G-oriented : is-oriented G)
         (nodes : List (Graph.Node G))
         (nodes-complete : ∀ (n : Graph.Node G) → n ∈ nodes)
         (edge? : ∀ (x y : Graph.Node G) → Dec (Graph.Edge G x y))
         (node-eq? : ∀ (x y : Graph.Node G) → Dec (x ≡ y))
         where

  open ForkConstruction G G-oriented nodes nodes-complete edge? node-eq?

  {-|
  ### Step 3.1: Non-star Predicate

  Define which vertices of Γ̄ belong to X.
  A vertex is in X iff it is NOT a fork-star vertex.
  -}

  is-non-star : ForkVertex → Ω
  is-non-star (a , v-original) = elΩ ⊤
  is-non-star (a , v-fork-star) = elΩ ⊥
  is-non-star (a , v-fork-tang) = elΩ ⊤

  {-|
  **Mathematical Note**:
  - v-original corresponds to "type a" in the paper
  - v-fork-tang corresponds to "type A" (tangs)
  - v-fork-star corresponds to "type A★" (excluded from X)
  -}

  is-non-star-is-prop : ∀ v → is-prop ⌞ is-non-star v ⌟
  is-non-star-is-prop (a , v-original) = hlevel 1
  is-non-star-is-prop (a , v-fork-star) = hlevel 1
  is-non-star-is-prop (a , v-fork-tang) = hlevel 1

  {-|
  ### Step 3.2: Characteristic Morphism to Ωᴳ

  Build the characteristic morphism χ : Γ̄ → Ωᴳ that classifies
  the subgraph of non-star vertices.

  **Construction**:
  - Map vertices to is-non-star proposition
  - Map edges to span: (is-non-star v ∧ is-non-star w) with projections
  -}

  -- Helper: An edge is in the subgraph if both endpoints are non-star
  is-non-star-edge : {v w : ForkVertex} → ForkEdge v w → Ω
  is-non-star-edge {v} {w} e = (is-non-star v) ∧Ω (is-non-star w)

  χ-non-star : Graph-hom Γ̄ (Ωᴳ {o ⊔ ℓ} {o ⊔ ℓ})
  χ-non-star .Graph-hom.node v = lift (is-non-star v)
  χ-non-star .Graph-hom.edge {v} {w} e =
    record
      { fst = lift (is-non-star-edge e)
      ; snd = (λ { (pv , pw) → pv }) , (λ { (pv , pw) → pw })
      }

  {-|
  **Explanation**:
  - Node part: v ↦ is-non-star v (proposition that v is not a star vertex)
  - Edge part: e : v → w maps to:
    - Edge prop: (is-non-star v) ∧ (is-non-star w)
    - Witness 1: (pv, pw) ⊢ pv (edge implies source is non-star)
    - Witness 2: (pv, pw) ⊢ pw (edge implies target is non-star)

  This is the standard construction from Cat.Instances.Graphs.Omega,
  specialized to our is-non-star predicate.
  -}

  {-|
  ### Step 3.3: X as Subgraph

  X is the subgraph of Γ̄ excluding A★ vertices.
  We define it directly as a Σ-type for simplicity.

  **Note**: This is equivalent to the pullback construction via Ωᴳ,
  but more direct for proving inheritance properties.
  -}

  X : Graph o (o ⊔ ℓ)
  X .Graph.Node = Σ[ v ∈ ForkVertex ] (⌞ is-non-star v ⌟)
  X .Graph.Edge (v , _) (w , _) = ForkEdge v w
  X .Graph.Node-set = Σ-is-hlevel 2 ForkVertex-is-set (λ _ → is-prop→is-set (hlevel 1))
  X .Graph.Edge-set {v , _} {w , _} = ForkEdge-is-set {v} {w}

  {-|
  **Mathematical interpretation**:
  - Vertices of X = {v ∈ Γ̄ | is-non-star v}
  - Edges in X = edges of Γ̄ between non-star vertices
  - This is exactly the subgraph excluding A★
  -}

  {-|
  ## Phase 4: X inherits Orientation from Γ̄

  Since X is a subgraph of Γ̄, it inherits the orientation properties.
  We prove each property by showing that X edges/paths are just Γ̄ edges/paths.
  -}

  {-|
  ### 4.1: X inherits classical property

  Edges in X are ForkEdges in Γ̄, which are propositions.
  -}
  subgraph-classical : is-oriented Γ̄ → (∀ {x y} → is-prop (Graph.Edge X x y))
  subgraph-classical Γ̄-or {(v , _)} {(w , _)} =
    -- Edges in X are ForkEdges v w
    -- Γ̄ is classical, so ForkEdge v w is a proposition
    is-classical Γ̄-or {v} {w}

  {-|
  ### 4.2: X inherits no-loops property

  A loop in X would be a ForkEdge v v in Γ̄, contradicting Γ̄'s no-loops.
  -}
  subgraph-no-loops : is-oriented Γ̄ → (∀ {x} → ¬ (Graph.Edge X x x))
  subgraph-no-loops Γ̄-or {(v , _)} edge =
    -- edge : ForkEdge v v
    -- But Γ̄ has no loops!
    has-no-loops Γ̄-or edge

  {-|
  ### 4.3: X inherits acyclicity

  Paths in X are paths in Γ̄ (just forgetting the is-non-star proofs).
  Γ̄'s acyclicity gives vertex equality, which lifts to X via Σ-path.
  -}

  -- Helper: Project paths from X to Γ̄ by forgetting is-non-star proofs
  project-path : ∀ {x y : Graph.Node X} → Path-in X x y → Path-in Γ̄ (fst x) (fst y)
  project-path {(v , _)} {(w , _)} nil = nil
  project-path {(v , _)} {(w , _)} (cons e rest) = cons e (project-path rest)

  subgraph-acyclic : is-oriented Γ̄ → (∀ {x y} → Path-in X x y → Path-in X y x → x ≡ y)
  subgraph-acyclic Γ̄-or {(v , pv)} {(w , pw)} path-fwd path-bwd =
    -- Project paths from X to Γ̄
    let path-fwd-Γ̄ : Path-in Γ̄ v w
        path-fwd-Γ̄ = project-path path-fwd

        path-bwd-Γ̄ : Path-in Γ̄ w v
        path-bwd-Γ̄ = project-path path-bwd

        -- Use Γ̄'s acyclicity to get v ≡ w
        v≡w : v ≡ w
        v≡w = is-acyclic Γ̄-or path-fwd-Γ̄ path-bwd-Γ̄
    -- Lift to Σ-path (equality of pairs)
    in Σ-pathp v≡w (is-prop→pathp (λ i → is-non-star-is-prop (v≡w i)) pv pw)

  X-oriented : is-oriented X
  X-oriented .fst x y = subgraph-classical Γ̄-oriented {x} {y}
  X-oriented .snd .fst x = subgraph-no-loops Γ̄-oriented {x}
  X-oriented .snd .snd x y = subgraph-acyclic Γ̄-oriented {x} {y}

  {-|
  ## Phase 5: Poset and Category Structures on X

  **Proposition 1.1(i)**: CX is a poset.

  The poset structure uses path-based reachability as the order relation.
  Antisymmetry follows from acyclicity.
  -}

  X-Poset : Poset o (o ⊔ ℓ)
  X-Poset .Poset.Ob = Graph.Node X
  X-Poset .Poset._≤_ x y = ∥ Path-in X x y ∥
  X-Poset .Poset.≤-thin = hlevel 1  -- Propositional truncation is a proposition
  X-Poset .Poset.≤-refl {x} = inc nil
  X-Poset .Poset.≤-trans {x} {y} {z} = ∥-∥-map₂ _++_
  X-Poset .Poset.≤-antisym {x} {y} p q =
    ∥-∥-rec (X .Graph.Node-set x y)
      (λ p' → ∥-∥-rec (X .Graph.Node-set x y)
        (λ q' → is-acyclic X-oriented p' q')
        q)
      p

  {-|
  **Key insight**: The antisymmetry law uses acyclicity!
  If we have paths x → y and y → x, then by acyclicity we get x ≡ y.
  This is exactly the proof from the paper's Proposition 1.1(i).
  -}

  X-Category : Precategory o (o ⊔ ℓ)
  X-Category .Precategory.Ob = Graph.Node X
  X-Category .Precategory.Hom x y = Path-in X x y
  X-Category .Precategory.Hom-set x y = path-is-set X
  X-Category .Precategory.id = nil
  X-Category .Precategory._∘_ q p = p ++ q  -- Diagram order: q ∘ p = "first p, then q"
  X-Category .Precategory.idr f = refl       -- f ∘ id = f → nil ++ f = f (trivial)
  X-Category .Precategory.idl f = ++-idr f   -- id ∘ f = f → f ++ nil = f
  X-Category .Precategory.assoc f g h = ++-assoc h g f  -- (f∘g)∘h = f∘(g∘h) → h++(g++f) = (h++g)++f

  {-|
  **Note**: This is a thin category (poset-as-category) since paths are
  unique up to equality (path-is-set).
  -}

{-|
## Roadmap to DNN-Topos (Phase 6 - Future Work)

The poset X constructed above is the base category for the full topos structure
described in Section 1.5 of the paper.

### From the Paper (lines 568-571)

> "It is remarkable that the main structural part (which is the projection from
> a product to its components) can be interpreted by the fact that the presheaf
> is a sheaf for a natural Grothendieck topology J on the category C: in every
> object x of C the only covering is the full category C|x, except when x is of
> the type of A★, where we add the covering made by the arrows of the type
> a' → A★."

### Fork Grothendieck Topology J

**Coverage definition**:
```agda
fork-coverage : Coverage (to-category Γ̄) ℓ
fork-coverage .covers v =
  if is-fork-star v
  then IncomingArrows v  -- {a' → A★ | all incoming}
  else MaximalSieve v     -- Trivial coverage
```

**Grothendieck axioms**:
1. **has-is-prop**: Coverage membership is propositional
2. **stable**: Pullbacks preserve coverings
3. **maximal**: Identity morphism generates covering
4. **local**: Gluing compatible sections

### Sheaf Condition at A★

For any presheaf F on Γ̄ to be a sheaf:

**F(A★) ≅ ∏_{a'→A★} F(a')**

This is the **product decomposition** that makes sheafification replace:
- F(A★) with the product of F(a') for all incoming a'
- The identity map with the diagonal map

### Key Equivalences

**Corollary (line 749)**: C∼ ≃ C∧_X
- The topos of sheaves on (Γ̄, J)
- is equivalent to
- The category of presheaves on X

**Why**: Friedman's theorem - sites with trivial endomorphisms are equivalent
to presheaf toposes on subcategories with trivial coverings.

**Corollary (line 791)**: C∼ ≃ Sh(X, Alexandrov)
- The topos of sheaves on (Γ̄, J)
- is equivalent to
- Sheaves on X with Alexandrov topology

**Why**: X is a poset, so it has a natural Alexandrov topology. Presheaves
on X extend uniquely to sheaves on this topology.

### Implementation Plan (ForkTopos.agda)

**File**: `src/Neural/Graph/ForkTopos.agda`

```agda
module Neural.Graph.ForkTopos where

open import Neural.Graph.ForkPoset
open import Cat.Site.Grothendieck
open import Cat.Instances.Sheaves

-- Define the fork Grothendieck topology
fork-topology : Topology (to-category Γ̄) ℓ
fork-topology .covering v R =
  if-fork-star v (has-all-incoming R) (is-maximal R)
fork-topology .has-is-prop = ... -- Prove 4 axioms
fork-topology .stable = ...
fork-topology .maximal = ...
fork-topology .local = ...

-- Build the DNN-Topos
DNN-Topos : Precategory _ _
DNN-Topos = Sh[ to-category Γ̄ , fork-topology ]

-- Prove Corollary (line 749)
topos≃presheaves : DNN-Topos ≃ᶜ PSh X-Category
topos≃presheaves = Friedman-equivalence fork-trivial-coverings

-- Prove Corollary (line 791)
topos≃alexandrov : DNN-Topos ≃ᶜ Sh-Alexandrov X-Poset
topos≃alexandrov = Proposition-1.2 X-alexandrov-topology
```

### Mathematical Significance

The topos structure captures:
1. **Compositionality**: Functoriality of neural layers
2. **Information aggregation**: Sheaf condition at convergent nodes
3. **Backpropagation**: Natural transformations in the topos
4. **Semantic functioning**: Internal logic and type theory

This is the foundation for:
- Section 2: Stacks and groupoid actions (CNNs, equivariance)
- Section 3: Dynamics and homology (semantic information)
- Section 4: Memories and braids (LSTMs, temporal structure)
- Section 5: 3-categories and derivators (attention mechanisms)

**Current status**: Poset X implemented (this file)
**Next step**: Implement fork-topology and build DNN-Topos
**References**: Belfiore & Bennequin (2022), Sections 1.3-1.5
-}
