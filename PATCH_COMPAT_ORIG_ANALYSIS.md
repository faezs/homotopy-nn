# patch-compat-orig Proof Analysis

## Mathematical Context from Paper (Section 1.3)

**The Fork Surgery Construction**:

At each convergent layer `a` where multiple layers send information (say `a'`, `a"`, ...),
we perform a **surgery** in the category:

1. **Original arrows**: `a ← a'`, `a ← a"`, ... in C(Γ) (edges in Γ^op)
2. **Fork construction**: Introduce two new objects **A★** (fork-star) and **A** (fork-tang)
3. **New arrows**:
   - **Tines**: `a' → A★`, `a" → A★`, ... (incoming tips)
   - **Tang/Socket**: `A★ → A` (star to tang)
   - **Handle**: `a → A` (original to tang)

**Result**: The category C̄ replaces C(Γ) as the "opposite of the category freely generated by Γ̄"

**Key property**: Γ̄ is still oriented and without cycles

## The `patch-compat-orig` Challenge

### Goal
Prove: `F₁ G g (γ .η _ (F₁ F f x)) ≡ γ .η _ (F₁ F (g ++ f) x)`

### Variables in Scope
- `g : Path-in Γ̄ (fst₁, v-original) (v-node, v-original)` - **Γ̄-path between original vertices**
- `f : Path-in Γ̄ (v-node, v-original) (fst₂, v-fork-star)` - Γ̄-path from original to fork-star
- `γ : restrict(F) => restrict(G)` - natural transformation on **X-Category**
- `F, G` - sheaves on Γ̄ with fork-coverage

### The Type Mismatch
- `γ .is-natural` expects `lift-path` of an **X-path**
- We have `g` which is a **Γ̄-path**
- Error: `lift-path _f_2192 != g` when trying to apply naturality

## Core Structural Insight

**Theorem**: A path in Γ̄ between two original vertices **cannot pass through fork-star or fork-tang vertices**.

**Proof**:
1. **If path reaches fork-star**: By `star-only-to-tang` (line 622), the only outgoing edge goes to fork-tang
2. **If path reaches fork-tang**: By `tang-no-outgoing` (line 631), there are **no outgoing edges**
3. **Therefore**: Any path from original to original must use **only orig-edges**
4. **But**: orig-edges are exactly the edges in X! (edges between non-fork-star vertices)

**Consequence**: Every Γ̄-path between original vertices **is already an X-path** (up to vertex labeling)

## The Solution: Graph Homomorphism

### Conceptual View
This is a **subcategory inclusion**:
- **X ↪ Γ̄** via `embed` (defined lines 470-474)
- **embed** is **full on image**: Every Γ̄-morphism between X-objects factors through embed
- We need the **inverse homomorphism** on the image

### Path Structure (from 1Lab Cat.Instances.Free)

```agda
data Path-in (G : Graph) : Node → Node → Type where
  nil  : ∀ {a} → Path-in a a
  cons : ∀ {a b c} → Edge a b → Path-in b c → Path-in a c
```

**Key property**: Each edge `e : Edge a b` in `cons e p` determines the intermediate vertex `b`.

### Required Function

```agda
project-path-orig : ∀ {v w}
                  → (v-orig : snd v ≡ v-original)
                  → (w-orig : snd w ≡ v-original)
                  → Path-in Γ̄ v w
                  → Path-in X (v , non-star-proof v v-orig) (w , non-star-proof w w-orig)
```

### Construction by Induction on Path Structure

```agda
project-path-orig v-orig w-orig nil = nil

project-path-orig {v} {w} v-orig w-orig (cons e p) =
  -- e : ForkEdge v b for some intermediate vertex b
  -- By orig-to-orig-is-orig-edge: e must be orig-edge
  -- Therefore b must also be original (orig-edge only connects original vertices)
  cons e-as-X-edge (project-path-orig b-orig w-orig p)
  where
    b : ForkVertex
    b = edge-target e  -- The intermediate vertex

    b-orig : snd b ≡ v-original
    b-orig = orig-edge-preserves-original e v-orig

    e-as-X-edge : X.Edge (v , ...) (b , ...)
    e-as-X-edge = e  -- Syntactically the same!
```

**Key lemma needed**:
```agda
orig-to-orig-is-orig-edge : ∀ {v w}
  → (v-orig : snd v ≡ v-original)
  → (w-orig : snd w ≡ v-original)
  → (e : ForkEdge v w)
  → ∃[ x ] ∃[ y ] ∃[ edge ] ∃[ non-conv ] e ≡ orig-edge x y edge non-conv _ _
```

**Proof**: Case analysis on `e`:
- `orig-edge`: ✓ This is the constructor we want
- `tip-to-star`: Target is fork-star, contradicts `w-orig`
- `star-to-tang`: Source is fork-star, contradicts `v-orig`
- `handle`: Source is fork-tang, contradicts `v-orig`

## The Proof Strategy

Once we have `project-path-orig`:

```agda
patch-compat-orig {g = g} =
  let g-X : Path-in X _ _
      g-X = project-path-orig refl refl g

      -- lift-path g-X ≡ g (up to proofs)
      roundtrip : lift-path g-X ≡ g
      roundtrip = lift-project-roundtrip g refl refl

  in ap (γ .η _) (sym (happly (F .F-∘ g f) x))
     ∙ sym (happly (γ .is-natural _ _ g-X) (F₁ F f x))
     ∙ ap (λ p → F₁ G p _) roundtrip
```

**Pattern from 1Lab** (Cat.Site.Base.lagda.md:293):
```agda
map-patch eta x .patch f hf g hgf =
  sym (eta .is-natural _ _ _ $ₚ _) ∙ ap (eta .η _) (x .patch f hf g hgf)
```

## Sources to Reconsult After Compaction

### Primary Implementation Files

1. **ForkTopos.agda lines 459-474**: `lift-path` and `embed` functor
   - Shows how X embeds into Γ̄ as a subcategory
   - `lift-path : Path-in X x y → Path-in Γ̄ (fst x) (fst y)`
   - Our function is the **inverse** on paths between original vertices

2. **ForkTopos.agda lines 622-640**: Edge structure lemmas
   - `star-only-to-tang` (622): `ForkEdge (a, v-fork-star) w → w ≡ (a, v-fork-tang)`
   - `tang-no-outgoing` (631): `¬ ForkEdge (a, v-fork-tang) w`
   - `tang-path-nil` (638): `Path-in Γ̄ (a, v-fork-tang) w → (a, v-fork-tang) ≡ w`
   - **These prove paths cannot pass through fork vertices!**

3. **ForkCategorical.agda**: ForkEdge definition (search for `data ForkEdge`)
   - `orig-edge`: Edges between non-convergent vertices (the X-edges)
   - `tip-to-star`: Tines `a' → A★`
   - `star-to-tang`: Tang `A★ → A`
   - `handle`: Handle `a → A`
   - **Critical**: Check constructor constraints on vertex types

4. **ForkPoset.agda**: X-Category definition
   - `X : Graph` - Subgraph of non-fork-star vertices
   - `X.Edge (v, _) (w, _) = Γ̄.Edge v w` with non-fork-star proofs
   - Shows X-edges are syntactically the same as orig-edges in Γ̄

### 1Lab Reference Patterns

5. **Cat.Site.Base.lagda.md lines 288-293**: `map-patch` naturality pattern
   ```agda
   map-patch eta x .patch f hf g hgf =
     sym (eta .is-natural _ _ _ $ₚ _) ∙
     ap (eta .η _) (x .patch f hf g hgf)
   ```
   - This shows the standard way to prove patch compatibility
   - Uses naturality + functoriality

6. **Cat.Base.lagda.md lines 454-456**: Natural transformation definition
   ```agda
   is-natural : (x y : _) (f : C.Hom x y)
              → η y D.∘ F.₁ f ≡ G.₁ f D.∘ η x
   ```
   - In opposite category: `η x ∘ F.F₁ f^op ≡ G.F₁ f^op ∘ η y`
   - For presheaves (contravariant): `η y (F.F₁ f z) ≡ G.F₁ f (η x z)`

### Paper References

7. **Belfiore & Bennequin (2022), Section 1.3**: Fork construction motivation
   - Explains the surgery at convergent vertices
   - Defines tines, tang/socket, handle
   - States Γ̄ remains oriented and acyclic

8. **Belfiore & Bennequin (2022), Proposition 1.1(i)**: "C_X is a poset"
   - Path uniqueness in oriented graphs
   - Connects to our use of path equality

## Implementation Checklist

### Step 1: Define `project-path-orig`
- [ ] Prove `orig-to-orig-is-orig-edge` lemma
- [ ] Implement `project-path-orig` by induction
- [ ] Prove `lift-project-roundtrip`: `lift-path (project-path-orig _ _ g) ≡ g`

### Step 2: Prove `patch-compat-orig`
- [ ] Use `project-path-orig` to get `g-X : Path-in X _ _`
- [ ] Apply `γ .is-natural _ _ g-X`
- [ ] Use `F .F-∘` for functoriality
- [ ] Use `roundtrip` to connect back to `g`

### Step 3: Apply to goal 1
- [ ] Fill patch goal with `patch-compat-orig`
- [ ] May need explicit vertex proofs for `.part` expansion

### Step 4: Complete α naturality (goal 2)
- [ ] Case split on source and target vertex types
- [ ] Use sheaf gluing for fork-star cases
- [ ] Use γ naturality for original/tang cases

## Why This Works: Category Theory

**The Big Picture**:
1. **X is a subcategory** of Γ̄ (non-fork-star vertices)
2. **embed : X-Category → Γ̄-Category** is full on image
3. **Fullness** means: Every Γ̄-morphism between X-objects comes from X
4. **project-path-orig** witnesses this fullness for paths between original vertices
5. **Naturality of γ** on X-Category transfers to Γ̄-Category via this projection

**Subobject Classifier View**:
- X is the subobject of Γ̄ classified by `is-not-fork-star : ForkVertex → Type`
- The characteristic morphism `χ : Γ̄ → Ω` factors through `⊤ : X → Ω`
- Paths in X are exactly paths in Γ̄ that stay in the fiber over ⊤

**Graph Homomorphism View**:
- `embed` is a graph homomorphism (preserves edges and composition)
- `project-path-orig` is the inverse homomorphism on the image
- The fork construction's edge structure makes this well-defined

## Potential Simplifications

**Alternative approach**: Since Γ̄-paths between original vertices **are** X-paths structurally, we might not need an explicit projection function. Instead:

1. Define a **type equivalence**:
   ```agda
   Γ̄-path-orig≃X-path : ∀ v w → (Path-in Γ̄ (v, v-original) (w, v-original))
                                ≃ Path-in X (v, ...) (w, ...)
   ```

2. Use this equivalence to transport γ's naturality to Γ̄-paths

This might be cleaner than explicit projection, using cubical type theory's transport.

## Summary

The `patch-compat-orig` proof requires:
1. **Recognizing** that paths between original vertices cannot escape to fork vertices
2. **Projecting** Γ̄-paths to X-paths (or proving equivalence)
3. **Applying** γ's naturality on the projected X-path
4. **Using** functoriality to relate composition

This is fundamentally a **subcategory inclusion** argument, leveraging the structural impossibility of certain edge sequences in the fork construction.
